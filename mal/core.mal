(def! inc (fn* [x] (+ x 1)))
(def! dec (fn* [x] (- x 1)))
(def! second (fn* [xs] 
                  (nth xs 1)))
(def! negate (fn* [n] (* -1 n)))
(def! not (fn* [a] (if a false true)))
(def! reduce (fn* [f ini coll]
                  (if (first coll)
                    (reduce f (f ini (first coll)) (rest coll))
                    ini)))
(def! next (fn* [coll]
                (let* [x (rest coll)]
                      (if (empty? x)
                        nil
                        x))))

(defmacro! defmacro  (fn* [name params & xs]
                          (if (empty? xs)
                            (list 'defmacro! name (list 'fn* params))
                            (list 'defmacro! name (concat (list 'fn* params) xs)))))

(defmacro cond [& xs] (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) '(throw "odd number of forms to cond: ~xs")) (cons 'cond (rest (rest xs))))))

(def! range (fn* [& params]
                 (cond
                   (= (count params) 1) (range* 0 (first params) 1)
                   (= (count params) 2) (range* (first params) (second params) 1)
                   (= (count params) 3) (apply range* params))))





(defmacro fn [params & xs] `(fn* ~params (do ~@xs)))

(defmacro let [bindings & xs] `(let* ~bindings (do ~@xs)))

(defmacro loop [bindings & xs] `(loop* ~bindings (do ~@xs)))

(defmacro defn [name params & xs] `(def! ~name (fn ~params ~@xs)))

(defmacro time [& xs]
  `(let* [start-time (time-ms)
          res (do ~@xs)]
         (do
           (println "function executed in " (- (time-ms) start-time) " ms")
           res)))




(defmacro while [condition & body] `(if ~condition (do ~@body (while ~condition ~@body))))

(defmacro dotimes [binding & body]
  (let* [var (first binding)
        count (second binding)]
    `(let* [ivar (atom 0)]
       (while (< @ivar ~count)
         (let* [~var @ivar]
          ~@body)
         (swap! ivar inc)))))


(defmacro sdump_ [& xs]  (vec (map (fn [s] `[(quote ~s) ~s]) xs) ))
(defmacro sdump [& xs] `(let [syms (sdump_ ~@xs)] (reduce  (fn* [st sym] (str st " " (first sym) "=" (second sym))) "sdump: " syms)))
;--------------
(defmacro comment [& xs] )

(defmacro when [condition & body] `(if ~condition (do  ~@body))) 


;------ debug functions
(defn debug-print [label value]
  (println (str label "=" value))
  value)

(defmacro debug-let [bindings & body]
  (let* [debugged-bindings (mapcat (fn* [sym-val_expr]
                                    (let* [s (first sym-val_expr)
                                          v (second sym-val_expr)]
                                      `[~s (debug-print (str "  let " (quote ~s)) ~v)]))
                                  (partition 2 bindings))]
    `(let* ~debugged-bindings ~@body)))


(def!  every? (fn* [pred coll]
                   (cond
                     (nil? (seq coll)) true
                     (pred (first coll)) (recur pred (next coll))
                     :else false)))

(def! some (fn* [pred coll]
                (cond
                  (nil? (seq coll)) false
                  (pred (first coll)) (first coll)
                  :else (recur pred (next coll)))))



(defmacro ns [&xs])

(def print-python-traceback (atom true))

(def! python-traceback-on (fn* [] (reset! print-python-traceback true)))

(def! python-traceback-off (fn* [] (reset! print-python-traceback false)))


(def! print_exception (fn* [e]
                           (do
                             (println (str "Exception: " (get e "err")))
                             (println (str "   executing: " (get e "a1")))
                             (let* [tb (get e "ast_info")
                                   tba (map (fn* [el] (str (pr-str (first el)) " - " (second el))) tb)
                                   tbs (join tba "\n   - ")
                                   ]
                               (println (str "   lisp traceback: \n   - " tbs)))
                             (if @print-python-traceback
                               (println (str "   " (get e "python_traceback")))))))

(defmacro try [& body]
  `(try* (do ~@body) (catch* ex (print_exception ex)))
  )


; repl
(def! repl-loop (fn* []
                     (let* [input (readline "pyclj > ")
                            result (try
                                     (eval (read-string input)))]
                           (do
                             (println result)
                             (recur)))))


; test framework
(def deftests (atom {}))

(defn do-report [d]
  (println "- " d))

(defn assert-expr [msg form]
  `(let [value__ ~form]
     (if value__
       (do-report {:type :pass, :message ~msg,
                   :expected '~form, :actual value__})
       (do-report {:type :fail, :message ~msg,
                   :expected '~form, :actual value__}))))

(defmacro try-expr [msg form]
  `(try* ~(assert-expr msg form)
          (catch* e
                  (do-report {:type :error, :message ~msg,
                              :expected '~form, :actual e}))))

(defmacro is [form] `(try-expr nil ~form))

(defmacro is-msg [form msg] `(try-expr ~msg ~form))

(defmacro deftest [name & body]
  `(swap! deftests assoc '~name '(do ~@body)))

(deftest addition (is (= 4 (+ 2 2))) (is (= 7 (+ 3 4))))

(defn run-test_ [sname]
  (let [body (get @deftests sname)]
    (if body
      (eval body)
      (str "test " sname "not defined !"))))

(defmacro run-test [name] `(run-test_ '~name))

(def! filter (fn* [pred coll]
                  (if (not (empty? coll))
                    (let* [x (first coll)]
                      (if (pred x)
                        (cons x (filter pred (rest coll)))
                        (filter pred (rest coll)))
                      )
                    coll)))

(def! identity (fn [x] x))

(defmacro and
  [& exprs]
  (when exprs
    `(let* [sym ~(first exprs)]
       (if sym
         ~(if (next exprs)
            `(and ~@(rest exprs))
            'sym)
         sym))))


(defmacro ->>
  [x & xs]
  (loop [x x, forms xs]
    (if forms
      (let* [form (first forms)
            threaded (if (list? form)
                       (with-meta `(~(first form) ~@(next form)  ~x) (meta form))
                       (list form x))]
        (recur threaded (next forms)))
      x)))

; Destructure let
(def get-paths-sequential)
(def get-paths-associative)
(def get-paths (fn* [bindings current-path]
                    (when bindings
                      (cond (sequential? bindings)
                            (get-paths-sequential bindings current-path)

                            (map? bindings)
                            (get-paths-associative bindings current-path)

                            :else
                            [[bindings current-path]]))))

(def get-paths-sequential (fn* [binding-seq current-path]
                               (do
                                 (def has_as? (fn* [bindings]
                                                   (and (>= (count bindings) 2) (= :as (nth bindings (- (count bindings) 2))))))
                                 (def variadic? (fn* [bindings]
                                                     (and (>= (count bindings) 2) (= '& (nth bindings (- (count bindings) 2))))))
                                 (let* [as (if (has_as? binding-seq) (last binding-seq) nil)
                                        binding-seq (if as (take (- (count binding-seq) 2) binding-seq) binding-seq)
                                        variadic-sym (if (variadic? binding-seq) (last binding-seq) nil)
                                        n-fixed-values (if variadic-sym (- (count binding-seq) 2) (count binding-seq))
                                        binding-seq (take n-fixed-values binding-seq)
                                        fixed-bindings (apply concat (map-indexed (fn* [i b] (get-paths b (conj current-path i))) binding-seq))
                                        fixed-bindings (if variadic-sym (conj fixed-bindings [variadic-sym [(negate n-fixed-values)]]) fixed-bindings)
                                        fixed-bindings (if as (conj fixed-bindings [as current-path]) fixed-bindings)]
                                       (vec fixed-bindings)))))
                                         
(def get-paths-associative (fn* [binding-map current-path]
                                (let* [default-map (get binding-map :or)
                                       keys-bindings (get binding-map :keys)
                                       as (get binding-map :as)
                                       binding-map (if as (dissoc binding-map :as) binding-map)
                                       binding-map (if default-map (dissoc binding-map :or) binding-map)
                                       binding-map (if keys-bindings
                                                     (apply hash-map (interleave keys-bindings
                                                                                 (map keyword keys-bindings)))
                                                     binding-map)
                                       ks (keys binding-map)
                                       vs (vals binding-map)
                                       f-get-path (fn* [k v]
                                                       (if (contains? default-map v)
                                                         (get-paths k (conj current-path [v (default-map v)]))
                                                         (get-paths k (conj current-path v))))
                                       paths (apply concat (map f-get-path ks vs))
                                       paths (if as (conj paths [as current-path]) paths)]
                                      (vec paths))))

(def butlast (fn* [coll]
                  (take (- (count coll) 1) coll)))

(def make-let-bindings (fn* [sym-path-def value]
                              (let* [sym (first sym-path-def)
                                     path (second sym-path-def)
                                     default (get-in sym-path-def [2])]
                                    (if (empty? path)
                                      [sym value]
                                      (if (and (number? (last path)) (< (last path) 0))
                                        (list sym (list 'drop  (negate (last path)) (list 'get-in value (butlast path)) ))
                                        (if default
                                          (list sym (list 'get-in value path default))
                                          (list sym (list 'get-in value path))))))))


(defmacro let [binding-vector & body]
  (apply list
         'let*
         (->> binding-vector
              (partition 2)
              (mapcat (fn* [bindings]
                           (if (symbol? (first bindings))
                             [(first bindings) (second bindings)]
                             (mapcat (fn* [b] (make-let-bindings b (second bindings)))
                                     (get-paths (first bindings) [])))))
              vec)
         (list (cons 'do body))))

; Destructure fn
(def make-v-pv-list (fn* [params]
                         (loop* [params params v-list [] pv-list []]
                                (if (empty? params)
                                  [v-list pv-list]
                                  (let* [param (first params)
                                         v (symbol (str "val" (quot (count pv-list) 2)))]
                                        (if (= param '&)
                                          (recur (rest params) (vec (concat v-list ['&])) pv-list)
                                          (recur (rest params) (vec (concat v-list [v])) (vec (concat pv-list [param v])))))))))

(defmacro fn-- [params & body]
  (let* [v-pv (make-v-pv-list params)
         v-list (first v-pv)
         pv-list (second v-pv)]
        `(fn* ~v-list
              (let [~@pv-list]
                (do ~@body)))))
    

; Multi Arity Functions
(defmacro fn [params & xs]
  (if (every? list? (cons params xs))
    (let* [make-pair (fn* [params-and-body]
                          (let* [params (first params-and-body)
                                 body (rest params-and-body)
                                 v-pv (make-v-pv-list params)
                                 v-list (first v-pv)
                                 pv-list (second v-pv)
                                 variadic? (and (> (count v-list) 1) (= '& (nth v-list (- (count v-list) 2))))
                                 k (if variadic? -1 (count v-list))]
                                [k `[~v-list (let [~@pv-list]
                                               (do ~@body))]]))
           maf-dict (apply hash-map (apply concat (map make-pair (cons params xs))))]
          `(fn** ~maf-dict))
    `(fn-- ~params  ~@xs)))

;(defmacro defn [name params & xs] `(def! ~name (fn ~params ~@xs))) ; redefined to use the new fn



(defmacro debug-eval [& vals]
  `(let* [f (fn [x]
             (println "code: " (str x) "\n    --> " (eval x)))]
     (map f  '~vals)))


(load-file "destruct.mal")
