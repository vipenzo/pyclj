{"find_path" : "(defn solutions [n]\r\n  (concat [(* n 2) (+ n 2)]\r\n    (if (even? n) [(/ n 2)] [])))\r\n\r\n(defn find-path [s e]\r\n  (loop [opts [s] depth 1]\r\n    (if (some #{e} opts)\r\n      depth\r\n        (recur (mapcat solutions opts) (inc depth)))))",
    "compress" : "(defn compress [s]\r\n  (map first\r\n       (partition-by identity s)))",
    "map" : "(def l '(6 7 8))", 
    "vectors" : "(def v [:a :b :c])",
    "ttt" : "(defn ttt [board]\r\n  (some {[:x :x :x] :x [:o :o :o] :o}\r\n        (concat board (apply map list board)\r\n                (for [d [[[0 0] [1 1] [2 2]] [[2 0] [1 1] [0 2]]]]\r\n                  (for [[x y] d] ((board x) y))))))",
    "pf" : "(defn pf [coll]\r\n  (remove nil?\r\n    (if-not (empty? coll)\r\n      (if (coll? (first coll))\r\n        (concat (pf (first coll)) (pf (rest coll)))\r\n        [coll]))))",
    "get_highest" : "(defn get-highest [& all]\r\n  (last (sort all)))",
    "penultimate" : "(defn penultimate [s]\r\n  (second (reverse s)))",
    "dupseq" : "(defn dupseq [s]\r\n  (interleave s s))",
    "digits" : "(defn digits [x y]\r\n  (map #(- (int %) (int \"0\")) (str (* x y))))",
    "primes" : "(defn prime? [n]\r\n  (cond\r\n     (or (= n 0) (= n 1)) false\r\n     (or (= n 2) (= n 3)) true\r\n     :else (= '(1) (filter #(= 0 (rem n %)) (range 1 (inc (Math/sqrt n)))))))\r\n\r\n(defn primes [n] (take n (filter prime? (range 1000))))",
    "getcaps" : "(defn getcaps [s]\r\n  (apply str (map first (re-seq #\"[A-Z]\" s))))",
    "roman" : "(defn roman [x]\r\n  (let [thousands [\"\" \"M\" \"MM\" \"MMM\" \"MMMM\" \"MMMMM\" \"MMMMMM\" \"MMMMMMM\" \"MMMMMMMM\" \"MMMMMMMMM\"]\r\n        hundreds [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\r\n        tens [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\r\n        ones [\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]]\r\n    (str (get thousands (quot x 1000))\r\n         (get hundreds (quot (mod x 1000) 100))\r\n         (get tens (quot (mod (mod x 1000) 100) 10))\r\n         (get ones (mod (mod (mod x 1000) 100) 10)))))",
    "totient" : "(defn gcd [a b] (if (zero? b) a (gcd b (mod a b))))\r\n\r\n(defn totient [n]\r\n    (if (= 1 n) 1\r\n      (->> (range 1 n)\r\n             (map (partial gcd n))\r\n             (filter #(= 1 %))\r\n             count)))",
    "lists" : "(def l (list :a :b :c))",
    "hello" : "(defn hello [name]\r\n  (str \"Hello, \" name \"!\"))",
    "symmetric" : "(defn m [v-l-r]\r\n  (if (first v-l-r)\r\n    [(first v-l-r) (m (last v-l-r)) (m (second v-l-r))]))\r\n\r\n(defn symmetric? [t]\r\n  (= t (m t)))",
    "lt" : "#_(defn lt [cols]\r\n  (let [row-num (dec (count cols))\r\n        col-num\r\n        (loop [acc -1 cur (apply max cols)]\r\n          (if (= 0 cur) acc\r\n              (recur (inc acc) (quot cur 2))))\r\n        is-mine\r\n        (fn [r c]\r\n          (if (or (nil? r) (nil? c) (> c col-num) (> r row-num)) false\r\n              (let [validate-v (bit-shift-left 1 (- col-num c))\r\n                    candidate-v (nth cols r)]\r\n                (> (bit-and validate-v candidate-v) 0))))\r\n        line-from (fn [r c fr fc] (if (is-mine r c)\r\n                                    (loop [acc [] next-col (fc c) next-row (fr r) l 2]\r\n                                      (if (or (> next-col col-num) (> next-row row-num) (not (is-mine next-row next-col)))\r\n                                        acc\r\n                                        (recur (concat acc [{:r1 r :c1 c :r2 next-row :c2 next-col :l l :fr fr :fc fc}])\r\n                                               (fc next-col)\r\n                                               (fr next-row)\r\n                                               (inc l))))\r\n                                    []))\r\n        mix-cols (fn [col1 col2] (mapcat (fn [e] (map (fn [e1] [e e1]) col1)) col2))\r\n        all-line-from (fn [r c] (concat (line-from r c inc inc)\r\n                                        (line-from r c inc identity)\r\n                                        (line-from r c identity inc)\r\n                                        (line-from r c inc dec)))\r\n        size1 (fn [a b c] (let [mxl (max a b c) mnl (min a b c)]\r\n                            (/ (* (inc mxl) mnl) 2)))\r\n        validate-tr (fn [l1 l2] (and (= (l1 :r2) (l2 :r2)) (= (l1 :c2) (l2 :c2))\r\n                                     (not (and (= (l1 :fr) (l2 :fr)) (= (l1 :fc) (l2 :fc))))))\r\n        triangle-from-line (fn [line] (let [lines1 (all-line-from (line :r1) (line :c1))\r\n                                            lines2 (all-line-from (line :r2) (line :c2))\r\n                                            line-combines (mix-cols lines1 lines2)\r\n                                            validate-combines (filter #(validate-tr (first %) (second %)) line-combines)]\r\n                                        (map #(size1 (line :l) ((first %) :l) ((second %) :l)) validate-combines)))\r\n        all-lines (flatten (let [points (mix-cols (range (inc row-num)) (range (inc col-num)))]\r\n                             (mapcat #(apply all-line-from %) points)))\r\n\r\n        all-size (flatten (map triangle-from-line all-lines))]\r\n    (if (empty? all-size) nil (apply max all-size))))",
    "maths" : "(def expr (= (- 10 (* 2 3)) 4))",
    "strings" : "(def s (. \"'hello'.toUpperCase\"))",
    "f" : "(defn neighbors [xy]\r\n  [[(inc (first xy)) (last xy)]\r\n   [(dec (first xy)) (last xy)]\r\n   [(first xy) (inc (last xy))]\r\n   [(first xy) (dec (last xy))]])\r\n\r\n(defn parts [grid]\r\n  (for [y (range (count grid))\r\n        x (range (count (nth grid y)))\r\n        :let [e (get-in grid [y x])]]\r\n         [(get {\"C\" :cat \"M\" :mouse \"#\" :wall \" \" :space} e) [x y]]))\r\n\r\n(defn f [grid]\r\n  (let [game (apply merge-with conj {:wall [] :space []} parts)\r\n        spaces (conj (set (:space game)) (:mouse game))]\r\n    (loop [open [(:cat game)] visited #{}]\r\n      (cond\r\n        (empty? open) false\r\n        (= (first open) (:mouse game)) true\r\n        :else (let [visited (conj visited (first open))\r\n                    neigh (filter spaces (neighbors (first open)))\r\n                    neigh (remove visited neigh)\r\n                    open (concat (rest open) (remove visited neigh))]\r\n                (recur open visited))))))",
    "drop_every_nth" : "(defn drop-every-nth [s n]\r\n  (apply concat (partition-all (dec n) n s)))",
    "my_merge_with" : "(defn my-merge-with [f & ms]\r\n  (reduce (fn [am m]\r\n            (into am (for [[k v] m]\r\n                       (if (contains? am k)\r\n                         [k (f (get am k) v)]\r\n                         [k v]))))\r\n          ms))",
    "deinterleave" : "(defn deinterleave [coll n]\r\n  (apply map list (partition n coll)))",
    "my_trampoline" : "(defn my-trampoline [f & x]\r\n  (if (fn? f)\r\n    (my-trampoline (apply f x))\r\n    f))",
    "pascal" : "(defn pascal [n]\r\n  (if (= n 1)\r\n     [1]\r\n     (map #(apply + %)\r\n          (partition 2 1 (concat [0] (pascal (- n 1)) [0])))))",
    "cw" : "(defn cw [word board]\r\n  (let [across (map #(str/escape % {\" \" \"\", \\_ \\.}) board)\r\n        down (apply map str across)]   ;; transpose the board so down becomes across\r\n    (string? (->> (concat across down)\r\n                  (mapcat #(str/split % #\"#\"))\r\n                  (some #(re-matches (re-pattern %) word))))))",
    "pack" : "(defn pack [s]\r\n   (loop [s (rest s) prev (first s) res [] subseq [(first s)]]\r\n     (if (seq s)\r\n       (let [f (first s)]\r\n         (if (= f prev)\r\n           (recur (rest s) f res (conj subseq f))\r\n           (recur (rest s) f (conj res (seq subseq)) [f])))\r\n       (conj res (seq subseq)))))",
    "powerset" : "(defn powerset [s]\r\n  (reduce #(into % (for [subset %] (conj subset %2))) #{#{}} s))",
    "lcm" : "(defn gcd [a b] (if (zero? b) a (gcd b (mod a b))))\r\n\r\n(defn lcm [& args]\r\n    (/ (reduce * 1 args) (reduce gcd 1 args))))",
    "anagram" : "(defn anagram [s]\r\n  (->> (group-by set s)\r\n       (vals)\r\n       (map set)\r\n       (filter #(> (count %) 1))\r\n       (set)))",
    "ss" : "(defn digits [n]\r\n  (if (< n 10)\r\n       (list n)\r\n       (cons (rem n 10) (digits (quot n 10)))))\r\n\r\n(defn ss [coll]\r\n    (count (filter\r\n            #(< % (apply + (map * (digits %) (digits %))))\r\n            coll)))",
    "graph" : "(defn graph [g]\r\n  ((fn f [e]\r\n     (#(if (= e %) (= % g) (f %))\r\n      (reduce (fn [a b] (into a (filter #(some (set b) %) g)))\r\n              #{}\r\n              e)))\r\n   #{(first g)}))",
    "set_sect" : "(defn set-sect [s1 s2]\r\n  (loop [res #{}\r\n  s1 s1]\r\n(if (empty? s1)\r\nres\r\n(recur (if (contains? s2 (first s1))\r\n        (conj res (first s1))\r\n        res) (rest s1)))))",
    "flipper" : "(defn flipper [f]\r\n  (fn [& args] (apply f (reverse args))))",
    "word_chain" : "(defn add [x y]\r\n  (some #(and (= (take % (seq x)) (take % (seq y)))\r\n     (= (drop % (seq x)) (drop (inc %) (seq y))))\r\n       (range (inc (count x)))))\r\n\r\n(defn subst [x y] \r\n  (some #(and (= (take % x) (take % y))\r\n        (= (drop (inc %) x) (drop (inc %) y)))\r\n        (range (count x))))\r\n\r\n\r\n(defn search\r\n    ([x] (if (some #(search x %) x) true false))\r\n    ([x w] (or (empty? (disj x w))\r\n               (some #(and (or (add w %) (add % w) (subst w %))\r\n                           (search (disj x w) %))\r\n                     (disj x w)))))\r\n\r\n(defn word-chain [s]\r\n  (search s))",
    "ps" : "(defn prime? [n]\r\n  (empty? (filter identity (map #(= 0 (mod n %)) (range 2 (inc (int (Math/sqrt n))))))))\r\n\r\n(defn next-prime [f n]\r\n  (loop [n (f n)]\r\n    (if (prime? n)\r\n         n\r\n       (recur (f n)))))\r\n\r\n(defn ps [n]\r\n  (let [isprime? (and (> n 2) (prime? n))\r\n        b4 (next-prime dec n)\r\n        after (next-prime inc n)\r\n        avg (/ (+ b4 after) 2)]\r\n    (and isprime? (= avg n))))",
    "maps" : "(def n 20)",
    "seq_prons" : "#_(defn seq-prons [n]\r\n  (let [get-pronunciation (fn [x]\r\n    (loop [curr (first x) count 1\r\n           remaining (rest x) acc []]\r\n      (cond (empty? remaining) (conj acc count curr)\r\n       (= curr (first remaining))\r\n         (recur curr (inc count) (rest remaining) acc)\r\n       :else\r\n         (recur (first remaining) 1 (rest remaining) (conj acc count curr)))))]\r\n    (cons (get-pronunciation n) (seq-prons (get-pronunciation n)))))",
    "hack" : "(defn hack [n s]\r\n  [(take n s) (drop n s)])",
    "reverse_seq" : "(defn reverse-seq [s]\r\n  (reduce conj () s))",
    "makeflat" : "(defn makeflat [s]\r\n  (filter (complement sequential?)\r\n          (rest (tree-seq sequential? seq s))))",
    "rest" : "(def v [20 30 40])",
    "perfect_nums" : "(defn perfect-nums [x]\r\n  (= x (apply + (filter #(= 0 (mod x %)) (range 1 x)))))",
    "closure" : "(defn closure [n]\r\n  (fn [x]\r\n    (apply * (repeat n x))))",
    "intervals" : "(defn intervals [coll]\r\n  (let [abc (sort coll)\r\n        a (first abc)\r\n        finish (fn [[acc a z]] (if-not z acc (conj acc [a z])))]\r\n    (->> abc\r\n         (reduce\r\n          (fn [[acc a z] nxt]\r\n            (if (<= nxt (inc z))\r\n              [acc a nxt]\r\n              [(conj acc [a z]) nxt nxt]))\r\n          [[] a a])\r\n         finish)))",
    "gtw" : "(defn gtw [n p x-xs]\r\n  (remove nil?\r\n  (if (p (first x-xs))\r\n    (if (= 1 n)\r\n      nil\r\n      (cons (first x-xs) (gtw (dec n) p (rest x-xs))))\r\n    (cons (first x-xs) (gtw n p (rest x-xs))))))",
    "conj_list" : "(def l '(1 2 3 4))",
    "camel" : "(defn camel [s]\r\n  (let [words (re-seq #\"[a-zA-Z]+\" s)\r\n        words (cons (first words)\r\n                    (map str/capitalize\r\n                         (rest words)))]\r\n    (apply str words)))",
    "splatter" : "(defn splatter [s n]\r\n  (mapcat\r\n   (fn [s]\r\n     (repeat n s)) s))",
    "split_by_type" : "(defn split-by-type [s]\r\n  (vals (group-by type s)))",
    "gcd" : "(defn gcd [a b]\r\n  (if (= 0 b) a (gcd b (mod a b))))",
    "conj_map" : "(def kv [:b 2])",
    "tree" : "(defn tree? [n]\r\n  (or (nil? n)\r\n      (and (coll? n)\r\n           (= 3 (count n))\r\n           (every? tree? (rest n)))))",
    "key_val" : "(defn key-val [s]\r\n  (loop [r s\r\n         a {}\r\n         k nil]\r\n    (if-let [f (first r)]\r\n      (if (keyword? f)\r\n        (recur (rest r)\r\n               (assoc a f [])\r\n               f)\r\n        (recur (rest r)\r\n               (assoc a k (conj (get a k) f))\r\n               k))\r\n      a)))",
    "mymap" : "(defn mymap [f l]\r\n  (rest (reductions (fn [_ x] (f x)) 0 l)))",
    "classes" : "(defn classes [f c]\r\n  (set (map set (vals (group-by f c)))))",
    "bin" : "(defn char->bit [c]\r\n  (get {\"0\" 0 \"1\" 1} c))\r\n\r\n(defn step [acc c]\r\n  (+ (* 2 acc) (char->bit c)))\r\n\r\n(defn bin [s]\r\n  (reduce step 0 s))",
    "myrange" : "(defn myrange [start end]\r\n  (loop [n start res []]\r\n   (if (>= n end) res (recur (inc n) (conj res n)))))",
    "conj_vector" : "(def v [1 2 3 4])",
    "my_interleave" : "(defn my-interleave [a b]\r\n  (mapcat list a b))",
    "factorial" : "(defn factorial [n]\r\n  (reduce * 1 (range 1 (inc n))))",
    "filter" : "(def l '(6 7))",
    "functions" : "(def n 8)",
    "seqs" : "(def n 3)",
    "uce" : "(defn uce [coll]\r\n  (fn [m]\r\n    (cond\r\n      (number? coll) coll\r\n      (symbol? coll) (get m coll)\r\n      :else (apply (cond\r\n                     (= '/ (first coll)) /\r\n                     (= '* (first coll)) *\r\n                     (= '+ (first coll)) +\r\n                     (= '- (first coll)) -)\r\n              (map #((uce %) m) (rest coll))))))",
    "make_map" : "(defn make-map [keys vals]\r\n  (apply hash-map (interleave keys vals)))",
    "my_group_by" : "(defn my-group-by [f s]\r\n  (reduce\r\n   (fn [m x] (assoc m (f x) (conj (get m (f x) []) x)))\r\n   {} s))",
    "fib" : "(defn fib [n]\r\n  (loop [f [1 1]]\r\n    (if (= n (count f))\r\n      f\r\n      (recur (conj f (+ (last f)\r\n                        (nth f (- (count f) 2))))))))",
    "shifter" : "(defn shifter [n c]\r\n  (cond\r\n     (= n 0) c\r\n     (< n 0) (shifter (+ (count c) n) c)\r\n     :else (shifter (dec n) (concat (rest c) (list (first c))))))",
    "nth_element" : "(defn nth-element [s n]\r\n  (last (take (inc n) s)))",
    "truth" : "(def truth (= true true))",
    "last" : "(defn my-last [s]\r\n  (if (next s)\r\n    (my-last (next s))\r\n    (first s)))",
    "spaz_out" : "(defn spaz-out [f x]\r\n  (reductions (fn [a b] (b a)) x (repeat 100 f)))",
    "mycomp" : "(defn mycomp\r\n  ([] identity)\r\n  ([f] f)\r\n  ([f g]\r\n   (fn\r\n     ([] (f (g)))\r\n     ([x] (f (g x)))\r\n     ([x y] (f (g x y)))\r\n     ([x y z] (f (g x y z)))\r\n     ([x y z & args] (f (apply g x y z args)))))\r\n  ([f g & fs]\r\n   (reduce comp (list* f g fs))))",
    "k" : "(defn k [k- s]\r\n  (cond\r\n    (zero? k-) #{#{}}\r\n    (empty? s) #{}\r\n    :else (set (set/union\r\n            (map #(conj % (first s)) (k (dec k-) (rest s)))\r\n            (k k- (rest s))))))",
    "myreductions" : "(defn my-reductions [f init xs]\r\n  (loop [s xs acc init res [init]]\r\n    (if (empty? s)\r\n      res\r\n      (recur (rest s)\r\n              (f acc (first s))\r\n             (conj res (f acc (first s)))))))",
    "conj_set" : "(def n 2)",
    "double" : "(def f \r\n  (fn [n]\r\n    (* n 2)))",
    "sym_diff" : "(defn sym-diff [a b]\r\n  (set/symmetric-difference a b))",
    "tri_path" : "(defn tri-path [s]\r\n  (first\r\n   (reduce\r\n    #(map + (map min (butlast %1) (rest %1)) %2)\r\n    (reverse s))))",
    "db" : "(defn digits [n b]\r\n  (if (< n b)\r\n    [n]\r\n    (conj (digits (quot n b) b) (rem n b))))",
    "sets" : "(def s #{:a :b :c :d})",
    "mypal" : "(defn mypal [s]\r\n  (= (seq s) (reverse (seq s))))",
    "cartesian" : "(defn cartesian [x y]\r\n  (set (for [a x b y] [a b])))",
    "perfect_square" : "(defn perfect-square [s]\r\n  (let [l (re-seq #\"\\\\d+\" s)]\r\n    (str/join \",\" (filter #{\"4\" \"9\" \"16\" \"25\" \"36\"} l))))",
    "inject" : "(defn inject [x coll]\r\n  (rest (interleave (repeat (count coll) x) coll)))",
    "word_sort" : "(defn word-sort [s]\r\n  (sort-by #(.toLowerCase %) (re-seq #\"\\w+\" s)))",
    "reversi" : "(defn reversi [board p]\r\n  (let [o '{b w w b}\r\n        d (for [y [-1 0 1] x (if (= 0 y) [-1 1] [-1 0 1])] [y x])\r\n        b (into {} (for [y (range 4) x (range 4)] [[y x] (get-in board [y x])]))\r\n        e (map key (filter #(= 'e (val %)) b))\r\n        wk (fn [st off] (take-while b (rest (iterate #(map + % off) st))))\r\n        vl (fn [pth] (let [s (apply str (map b pth)) r (re-pattern (str (o p) \"+\" p))]\r\n                       (if (re-seq r s) (take-while #(not= p (b %)) pth))))\r\n        mv (fn [st] (set (apply concat (keep vl (map #(wk st %) d)))))]\r\n    (into {} (for [st e :let [mvs (mv st)] :when (not-empty mvs)] [st mvs]))))",
    "lazy" : "(defn lazy [& colls]\r\n  (if (= 1 (count colls))\r\n    (first (first colls))\r\n    (let [heads (map first colls)\r\n          largest (apply max heads)]\r\n      (if (apply = heads)\r\n        largest\r\n        (recur (map\r\n                 (fn [c]\r\n                   (drop-while #(< % largest) c)) colls))))))",
    "sh" : "(defn sh [n [x & r]]\r\n  (if x\r\n    (if (sequential? x)\r\n      (let [sub (sh n x)]\r\n        (cons sub (sh (- n (reduce + 0 (flatten sub))) r)))\r\n      (if (<= x n)\r\n        (cons x (sh (- n x) r))\r\n        ()))))",
    "half_truth" : "(defn half-truth [& vs]\r\n  (true? (and (some not vs)\r\n              (some identity vs))))",
    "longest_subseq" : "(defn longest-subseq [s]\r\n  (let [longer? (fn [data x]\r\n                   (let [[longest xs] data\r\n                         new-xs (conj xs x)]\r\n                     (if (> x (peek xs))\r\n                       [(if (> (count new-xs) (count longest))\r\n                          new-xs\r\n                          longest) new-xs]\r\n                       [longest [x]])))\r\n         start (let [a (first s)]\r\n                 [[] [a]])]\r\n     (first (reduce longer? start s))))",
    "quine" : "(defn quine []\r\n  (fn []\r\n    (let [x '(list 'fn []\r\n                   (list 'let ['x (list 'quote x)]\r\n                         (list 'str x)))]\r\n      (str (list 'fn []\r\n                 (list 'let ['x (list 'quote x)]\r\n                       (list 'str x)))))))",
    "eulerian" : "(defn eulerian [e]\r\n  (if (#{0 2} (count (filter odd? (vals (frequencies (mapcat seq e))))))\r\n    (not (next (reduce\r\n                (fn [g e]\r\n                  (let [[a b] (map (fn [n] (or (some #(if (% n) %) g) #{n})) e)]\r\n                    (conj (disj g a b) (into a b))))\r\n                #{}\r\n                e)))\r\n    false))",
    "cards" : "(defn cards [c]\r\n  {:suit (get {\"H\" :heart \"C\" :club \"S\" :spade \"D\" :diamond} (first c))\r\n   :rank (get (zipmap \"23456789TJQKA\" (range 20)) (second c))})",
    "rn" : "(defn rn [n]\r\n  (->> (map #(get {\\C 100 \\D 500 \\I 1 \\L 50 \\M 1000 \\V 5 \\X 10} %) n)\r\n       (partition 2 1 [0])\r\n       (map (fn [ab] (if (< (first ab) (last ab)) (- (first ab)) (first ab))))\r\n       (apply +)))",
    "count_elements" : "(defn count-elements [s]\r\n  (loop [x s acc 0]\r\n    (if (empty? x)\r\n      acc\r\n      (recur (rest x) (inc acc)))))",
    "happy" : "(defn happy [n]\r\n  (loop [n n\r\n         s #{}]\r\n    (let [x (apply + (map #(let [i (- (int %) (int \"0\"))] (* i i)) (str n)))]\r\n      (cond (= x 1) true\r\n            (s x) false\r\n            :else (recur x (conj s x))))))",
    "bal_num" : "(defn bal-num [n]\r\n  (let [s (map #(- (int %) 48) (str n))\r\n        l (/ (count s) 2)\r\n        ab (map #(apply + (take l %)) [s (into () s)])]\r\n    (= (first ab) (last ab))))",
    "lev" : "(defn lev [s t]\r\n  (let [f (fn [f s t]\r\n            (cond\r\n              (empty? s) (count t)\r\n              (empty? t) (count s)\r\n              :else (let [cost (if (= (first s) (first t)) 0 1)]\r\n                      (min (inc (f f (rest s) t))\r\n                           (inc (f f s (rest t)))\r\n                           (+ cost (f f (rest s) (rest t)))))))\r\n        g (memoize f)]\r\n    (g g s t)))",
    "black_box" : " (defn black-box [c]\r\n  (get (zipmap (map str [{} #{} () []]) [:map :set :list :vector]) (str (empty c))))",
    "myjuxt" : "(defn myjuxt [& f]\r\n  (fn [& a]\r\n    (map #(apply % a) f)))",
    "trans_closure" : "(defn trans-closure [s]\r\n  (let [relate? (fn [[a b] [c d]] (when (= b c) [a d]))\r\n        relations (fn [a] (filter identity (map #(relate? a %) s)))\r\n        news (set/union s (mapcat #(relations %) s))]\r\n    (if (= s news) s (trans-closure news))))",
    "conway" : "(defn conway [b]\r\n  (let [w (count (first b)) h (count b)\r\n        cell (fn [x y] (if (and (> x -1) (> y -1) (< x w) (< y h)) (nth (nth b y) x)))\r\n        ox [-1 0 1 -1 1 -1 0 1]\r\n        oy [-1 -1 -1 0 0 1 1 1]]\r\n    (map #(apply str %)\r\n         (for [y (range h)]\r\n           (for [x (range w)]\r\n             (let [n (count (filter #(= \\# %) (map #(cell (+ x %1) (+ y %2)) ox oy)))]\r\n               (if (= \\# (cell x y))\r\n                 (cond (< n 2) \" \" (> n 3) \" \" :else \\#)\r\n                 (if (= n 3) \\# \" \"))))))))",
    "veitch" : "(defn veitch [I]\r\n  (disj (into #{} (map (fn [s]\r\n                         ((reduce\r\n                           (fn [[d f u] x]\r\n                             (let [U (disj u x)\r\n                                   m (fn [t] (map #(conj % t) f))\r\n                                   P #(symbol (.toUpperCase (str %)))\r\n                                   L #(symbol (.toLowerCase (str %)))\r\n                                   F (into (m (L x)) (m (P x)))]\r\n                               (if (every? #(contains? I %) (map #(into (into d U) %) F))\r\n                                 [d F U]\r\n                                 [(conj d x) f U])))\r\n                           [#{} [#{}] s]\r\n                           s) 0)) I))\r\n        '#{A d}))",
    "ttt2" : "(defn ttt [v x]\r\n  (into #{}\r\n     (filter\r\n       (fn [d]\r\n         (and (= (get-in x d) :e)\r\n           (let [a (assoc-in x d v) c (second (second a))]\r\n             (some #(= #{v} (set %))\r\n               (concat (apply map vector a)\r\n                 (conj a (vector (ffirst a) c (nth (nth a 2) 2))\r\n                   (vector (nth (nth a 0) 2) c (nth (nth a 2) 0))))))))\r\n       (for [i (range 3) j (range 3)] [i j]))))",
    "diamond" : "(def alphabet (map char (range (int \"A\") (inc (int \"Z\")))))\r\n\r\n(defn pad [x]\r\n  (apply str (repeat x \" \")))\r\n\r\n(defn one-row [letter [inner-padding outer-padding]]\r\n  (if (= inner-padding 0)\r\n    (str (pad outer-padding) letter (pad outer-padding))\r\n    (str (pad outer-padding) letter (pad inner-padding) letter (pad outer-padding))))\r\n\r\n(defn row-paddings [num-letters]\r\n  (let [inner-padding (conj (iterate (partial + 2) 1) 0)\r\n        outer-padding (iterate dec (dec num-letters))]\r\n    (take num-letters (map vector inner-padding outer-padding))))\r\n\r\n(defn diamond [c]\r\n  (let [num-letters (- (int c) (dec (int \"A\")))\r\n        top-half (map one-row alphabet (row-paddings num-letters))]\r\n    (concat top-half (rest (reverse top-half)))))\r\n",
    "isogram" : "(defn isogram? [word]\r\n  (apply distinct? (filter #(Character/isLetter %) (str/lower-case word))))\r\n",
    "gigasecond" : "(defn leap-year? [year]\n        (cond\n          (zero? (mod year 400)) true\n          (zero? (mod year 100)) false\n          :else (zero? (mod year 4))))\n     \n      (defn days-in-month [year month]\n        (cond\n          (= month 2) (if (leap-year? year) 29 28)\n          (some #(= month %) [4 6 9 11]) 30\n          :else 31))\n     \n      (defn days-to-next-month [year month day]\n        (+ (days-in-month year month) (- day) 1))\n     \n      (defn from [y m d]\n        (let [total-seconds 1000000000\n              seconds-per-day 86400\n              total-days (int (/ total-seconds seconds-per-day))]\n          (loop [year y\n                 month m\n                 day d\n                 remaining total-days]\n            (let [jump (days-to-next-month year month day)]\n              (if-not (>= remaining jump)\n                [year month (+ day remaining)]\n                (recur\n                 (if (zero? (mod month 12)) (inc year) year)\n                 (inc (mod month 12))\n                 1\n                 (- remaining jump)))))))\r\n",
    "leap" : "(defn leap-year? [year]\r\n    (let [pcs  (map #(= 0 (rem year %1)) [4 100 400])\r\n        p (first pcs)\r\n     c (second pcs)\r\n        s (last pcs)]\r\n    (or (and p (not c))\r\n        (and c s))))\r\n",
    "zipper" : "(defn from-trail [tree last]\r\n  (if (= (nth last 0) \"left\")\r\n    {:value (nth last 1), :left tree, :right (nth last 2)}\r\n    {:value (nth last 1), :left (nth last 2), :right tree}))\r\n\r\n(defn from-tree [tree]\r\n  {:tree tree :trail []})\r\n\r\n(defn value [z]\r\n  (:value (:tree z)))\r\n\r\n(defn zipper [tree trail]\r\n  {:tree tree :trail trail})\r\n\r\n(defn left [z]\r\n  (when (:left (:tree z))\r\n    (zipper (:left (:tree z))\r\n            (conj [[\"left\" (:value (:tree z)) (:right (:tree z))]]\r\n                  (:trail z)))))\r\n(defn right [z]\r\n  (when (:right (:tree z))\r\n    (zipper (:right (:tree z))\r\n            (conj [[\"right\" (:value (:tree z)) (:left (:tree z))]]\r\n                  (:trail z)))))\r\n\r\n(defn rebuild-tree [tree trail]\r\n  (if (= 0 (count trail))\r\n    tree\r\n    (recur (from-trail tree (first trail)) (fnext trail))))\r\n\r\n(defn to-tree [z]\r\n  (rebuild-tree (:tree z) (:trail z)))\r\n\r\n(defn up [z]\r\n  (when-not (zero? (count (:trail z)))\r\n    (zipper (from-trail (:tree z) (first (:trail z)))\r\n            (fnext (:trail z)))))\r\n\r\n(defn set-value [z value]\r\n  (zipper {:value value,\r\n           :left  (:left (:tree z)),\r\n           :right (:right (:tree z))}\r\n          (:trail z)))\r\n\r\n(defn set-left [z left]\r\n  (zipper {:value (:value (:tree z)),\r\n           :left  left,\r\n           :right (:right (:tree z))}\r\n          (:trail z)))\r\n\r\n(defn set-right [z right]\r\n  (zipper {:value (:value (:tree z)),\r\n           :left  (:left (:tree z)),\r\n           :right right}\r\n          (:trail z)))\r\n",
    "roman_numerals" : "(def numeral-mapping\r\n   [[1000 \"M\"]\r\n   [900 \"CM\"]\r\n   [500 \"D\"]\r\n   [400 \"CD\"]\r\n   [100 \"C\"]\r\n   [90 \"XC\"]\r\n   [50 \"L\"]\r\n   [40 \"XL\"]\r\n   [10 \"X\"]\r\n   [9 \"IX\"]\r\n   [5 \"V\"]\r\n   [4 \"IV\"]\r\n   [1 \"I\"]])\r\n\r\n(defn largest-factor [number]\r\n   (first (filter\r\n          (fn [pl] (<= (first pl) number))\r\n         numeral-mapping)))\r\n\r\n(defn numerals [number]\r\n  (if (zero? number) \"\"\r\n   (let [pl (largest-factor number)\r\n         remainder (- number (first pl))]\r\n     (str (last pl) (numerals remainder)))))\r\n",
    "minesweeper" : "(def ordinals\r\n  (disj (set (for [x [-1 0 1]\r\n                   y [-1 0 1]]\r\n               [x y])) [0 0]))\r\n\r\n(def glyphs {:bomb  \\*\r\n             :empty \" \"})\r\n\r\n(def bomb? #{(:bomb glyphs)})\r\n\r\n(defn bombs [tiles coords]\r\n  (count (filter #(bomb? (get-in (vec tiles) (map + coords %)))\r\n            ordinals)))\r\n\r\n(defn sweep [tiles coords]\r\n  (let [hits (bombs tiles coords)]\r\n    (if (zero? hits)\r\n      (:empty glyphs)\r\n      hits)))\r\n\r\n(defn flag [tiles coords]\r\n  (if (bomb? (get-in (vec tiles) coords))\r\n    (:bomb glyphs)\r\n    (sweep tiles coords)))\r\n\r\n(defn draw [board]\r\n  (let [tiles  (str/split-lines board)\r\n        width  (count (first tiles))\r\n        height (count tiles)\r\n        reveal (for [y (range width) x (range height)]\r\n                 (flag tiles [x y]))]\r\n    (str/join \"\\n\" (map str/join (partition width reveal)))))\r\n",
    "pov" : "(defn path-to [tree to]\r\n  (loop [tree tree\r\n         path []\r\n         stack '()]\r\n    (cond\r\n      (= to (first tree)) (conj path (first tree))\r\n      (= (count tree) 2) (recur (second tree) (conj path (first tree)) stack)\r\n      (> (count tree) 2) (recur (second tree) (conj path (first tree))\r\n                                (concat stack (for [x (drop 2 tree)] [x (conj path (first tree))])))\r\n      (empty? stack) nil\r\n      :else (let [stack-elem (first stack)]\r\n              (recur (first stack-elem) (second stack-elem) (drop 1 stack))))))\r\n\r\n(defn find-elem-in-tree [tree elem]\r\n  (loop [tree tree\r\n         remaining (drop 1 tree)]\r\n    (cond\r\n      (= (first tree) elem) tree\r\n      (empty? remaining) nil\r\n      :else (recur (first remaining) (drop 1 remaining)))))\r\n\r\n(defn remove-elem-in-tree [tree elem]\r\n  (into [] (remove\r\n             #(\r\n                or (= % elem) (and (vector? %) (= (first %) elem)))\r\n             tree)))\r\n\r\n(defn tree-elems-from-path [tree path]\r\n  (loop [elems []\r\n         branch tree\r\n         path path]\r\n    (cond (empty? path) elems\r\n    :else (let [elem (find-elem-in-tree branch (first path))]\r\n            (recur (conj elems (remove-elem-in-tree elem (second path))) elem (drop 1 path))))))\r\n\r\n(defn resort-elems [elems]\r\n  (loop [tree (first elems)\r\n         elems (drop 1 elems)]\r\n    (cond\r\n      (empty? elems) tree\r\n      :else (recur (conj (first elems) tree) (drop 1 elems)))))\r\n\r\n(defn of [to tree]\r\n  (->> (path-to tree to)\r\n       (tree-elems-from-path tree)\r\n       (resort-elems)))\r\n\r\n(defn path-from-to [from to tree]\r\n  (path-to (of from tree) to))\r\n",
    "matching_brackets" : "(defn valid? [s]\r\n  (let [pairs {\")\" \"(\" \"]\" \"[\" \"}\" \"{\"}\r\n        opening (set (vals pairs))\r\n        closing (set (keys pairs))]\r\n    (loop [stack [] s s]\r\n      (cond (empty? s) (empty? stack)\r\n            (contains? opening (first s)) (recur (conj stack (first s)) (rest s))\r\n            (contains? closing (first s)) (if (= (peek stack) (get pairs (first s)))\r\n                          (recur (pop stack) (rest s))\r\n                          false)\r\n            :else (recur stack (rest s))))))\r\n",
    "dominoes" : "(defn build-graph [edges vertices]\r\n  (reduce (fn [s [a b]] (-> s\r\n                            (update a #(conj % b))\r\n                            (update b #(conj % a))))\r\n          (reduce #(assoc %1 %2 []) {} vertices) edges))\r\n\r\n(defn dfs [graph vertex]\r\n  (loop [stack (vector vertex)\r\n         visited #{}]\r\n    (if (empty? stack)\r\n      visited\r\n      (let [v (peek stack)\r\n            not-visited-neighbors (remove #(visited %) (graph v))]\r\n        (recur (into (pop stack) not-visited-neighbors)\r\n               (if (visited v) visited (conj visited v)))))))\r\n\r\n(defn can-chain? [edges]\r\n  (cond\r\n    (not (seq edges)) true\r\n    (some odd? (vals (frequencies (flatten edges)))) false\r\n    :else (let [vertices (vec (distinct (flatten edges)))\r\n                graph (build-graph edges vertices)\r\n                path (dfs graph (first vertices))]\r\n            (== (count path) (count vertices)))))\r\n",
    "rotational_cipher" : "(defn rotate-int [low num n]\r\n  (+ low (mod (+ n (- num low)) 26)))\r\n\r\n(defn rotate-char [n c]\r\n    (if (Character/isLetter c)\r\n      (if (Character/isLowerCase (int c))\r\n        (char (rotate-int 97 (int c) n))\r\n        (char (rotate-int 65 (int c) n)))\r\n      c))\r\n\r\n(defn rotate [s n]\r\n  (apply str (map (fn [c] (rotate-char n c)) s)))\r\n",
    "kindergarten_garden" : "(def default-students [\"Alice\" \"Bob\" \"Charlie\" \"David\" \"Eve\" \"Fred\" \"Ginny\"\r\n                       \"Harriet\" \"Ileana\" \"Joseph\" \"Kincaid\" \"Larry\"])\r\n\r\n(def seeds {\\G :grass \\C :clover \\R :radishes \\V :violets})\r\n\r\n(defn row-to-seeds [row-string]\r\n  (map seeds row-string))\r\n\r\n(defn garden-to-rows [garden]\r\n  (str/split-lines garden))\r\n\r\n(defn garden\r\n  ([string]\r\n   (garden string default-students))\r\n  ([string students]\r\n   (let [students     (map #(keyword (str/lower-case %1)) (sort students))\r\n         [front back] (map #(partition 2 %1)\r\n                           (map row-to-seeds (garden-to-rows string)))]\r\n     (->> (interleave front back)\r\n          (partition 2)\r\n          (map flatten)\r\n          (map vec)\r\n          (zipmap students)))))\r\n",
    "all_your_base" : "(defn- to-base-10 [digits from-base]\r\n  (reduce #(+ (* from-base %1) %2) 0 digits))\r\n\r\n(defn- from-base-10 [n to-base]\r\n  (loop [remaining n\r\n         result ()]\r\n    (let [quotient (quot remaining to-base)\r\n          result (cons (rem remaining to-base) result)]\r\n      (if (zero? quotient)\r\n        result\r\n        (recur quotient result)))))\r\n\r\n#_(defn convert [old-base digits new-base]\r\n  (cond (< old-base 2) nil\r\n        (< new-base 2) nil\r\n        (not-every? (partial contains? (set (range old-base))) digits) nil\r\n        (empty? digits) '()\r\n        :else (-> digits\r\n                  (to-base-10 old-base)\r\n                  (from-base-10 new-base))))\r\n",
    "spiral_matrix" : "(defn rotate [m]\r\n  (apply map (comp reverse vector) m))\r\n\r\n(defn range-n [start count]\r\n  (range start (+ start count)))\r\n\r\n(defn gen-row [start m]\r\n  (range-n start m))\r\n\r\n(defn spiral-mx\r\n  [n m start]\r\n  (cond \r\n    (= n 0) '()\r\n     (= n 1) [(gen-row start m)]\r\n       :else (cons (gen-row start m)\r\n              (rotate (spiral-mx m (dec n) (+ start m))))))\r\n  \r\n(defn spiral [n]\r\n  (spiral-mx n n 1))\r\n",
    "anagram2" : "(defn anagram? [w c]\r\n  (let [w (lower-case w)\r\n        c (lower-case c)]\r\n    (and (= (sort w) (sort c))\r\n         (not= w c))))\r\n\r\n(defn anagrams-for [w coll]\r\n  (filter (partial anagram? w) coll))\r\n",
    "atbash_cipher" : "(defn is-letter? [c]\r\n  (re-matches #\"[a-z]|[A-Z]\" c))\r\n\r\n(defn encode-char [c]\r\n  (if (is-letter? (str c))\r\n    (char (- (int \\z) (- (int c) (int \\a))))\r\n    c))\r\n\r\n(defn filter-non-alphanumerical [w]\r\n  (apply str (re-seq #\"[a-z]+|[A-Z]|[0-9]+\" w)))\r\n\r\n(defn split-five [w]\r\n  (re-seq #\".{1,5}\" w))\r\n\r\n(defn encode [w]\r\n  (->> w\r\n    (str/lower-case)\r\n    (filter-non-alphanumerical)\r\n    (map encode-char)\r\n    (apply str)\r\n    (split-five)\r\n    (str/join \" \")))\r\n",
    "grade_school" : "(defn add [db name grade]\r\n  (merge-with concat db (hash-map grade [name])))\r\n\r\n(defn grade [db grade]\r\n  (get db grade []))\r\n\r\n(defn sorted [db]\r\n  (->> db\r\n      (map (fn [k-v] [(first k-v) (sort (last k-v))]))\r\n      (into (sorted-map))\r\n      (sort)))\r\n",
    "meetup" : "(def day-structure\r\n  {1 :sunday 2 :monday 3 :tuesday 4 :wednesday\r\n   5 :thursday 6 :friday 7 :saturday})\r\n\r\n(defn leap-year? [year]\r\n  (cond (zero? (mod year 400)) true\r\n        (zero? (mod year 100)) false\r\n        :else  (zero? (mod year 4))))\r\n\r\n(defn zellers-congruence [input_year input_month input_day]\r\n  (let [month (+ (mod (+ input_month 9) 12) 3)\r\n        year (- input_year (quot (- month input_month) 12))\r\n        century (quot year 100)\r\n        century-year (mod year 100)]\r\n    (mod (+ input_day\r\n            (quot (* 26 (inc month)) 10)\r\n            century-year\r\n            (quot century-year 4)\r\n            (quot century 4)\r\n            (* 5 century)) 7)))\r\n\r\n(defn get-day-counts [year]\r\n  {1 31, 2 (if (leap-year? year) 29 28), 3 31, 4 30\r\n   5 31, 6 30, 7 31, 8 31, 9 30, 10 31, 11 30, 12 31})\r\n\r\n(defn get-days\r\n  ([year month]\r\n   (get-days year month\r\n             (zellers-congruence year month 1)\r\n             (get-in (get-day-counts year) [month])))\r\n  ([year month start-day limit]\r\n   (loop [count 2\r\n          day (inc start-day)\r\n          day-arrangement {1 (get-in day-structure [start-day])}]\r\n     (if (not= count (inc limit))\r\n       (recur  (inc count)\r\n               (if (= (inc day) 8) 1 (inc day))\r\n               (assoc day-arrangement count\r\n                      (get-in day-structure [day])))\r\n       day-arrangement))))\r\n\r\n(defn filter-by-day [year month day]\r\n  (let [days (get-days year month)]\r\n    (apply hash-map (flatten (filter #(-> % val (= day)) days)))))\r\n\r\n(defn filter-keys [year month day style]\r\n  (let [days (filter-by-day year month day)\r\n        dates (sort (keys days))]\r\n    (cond\r\n      (= style :first)\r\n      (nth dates 0)\r\n      (= style :second)\r\n      (nth dates 1)\r\n      (= style :third)\r\n      (nth dates 2)\r\n      (= style :fourth)\r\n      (nth dates 3)\r\n      (= style :last)\r\n      (nth dates (dec (count dates)))\r\n      (= style :teenth)\r\n      (first (filter #(and (> % 12) (< % 20)) (vec dates))))))\r\n\r\n(defn meetup [month year day style]\r\n  [year month (filter-keys year month day style)])",
    "two_fer" : "(defn two-fer\r\n  ([] \"One for you, one for me.\")\r\n  ([name]\r\n    (str \"One for \" name \", one for me.\")\r\n    \"One for you, one for me.\"))\r\n",
    "run_length_encoding" : "(defn encoder-groups [string]\r\n  (re-seq #\"(.)\\\\1*\" string))\r\n\r\n(defn encoder-values [group]\r\n  (str (if (> (count group) 1)\r\n         (count group)\r\n         \"\")\r\n       (first group)))\r\n\r\n(defn run-length-encode [s]\r\n  (let [groups (re-seq #\"(.)\\\\1*\" s)]\r\n    (apply str\r\n           (map encoder-values groups))))\r\n\r\n(defn decoder-groups [string]\r\n  (re-seq #\"(\\\\d+)?(.)\" string))\r\n\r\n(defn decoder-values [group]\r\n  (apply str\r\n    (repeat (when-let [n (first (re-seq #\"\\\\d+\" group))]\r\n               (Integer/parseInt n))\r\n            (last group))))\r\n\r\n(defn run-length-decode [s]\r\n  (let [groups (re-seq #\"(\\\\d+)?(.)\" s)]\r\n    (apply str\r\n           (map decoder-values groups))))\r\n",
    "wordy" : "(def  ops {\"plus\" +\r\n                    \"minus\" -\r\n                    \"multiplied by\" *\r\n                    \"divided by\" /})\r\n\r\n(def tokens-pattern\r\n   (str (join \"|\" (keys ops)) \"|-?\\\\d+|\\\\S+\"))\r\n\r\n(defn parse-op [op-str]\r\n  (or (ops op-str)\r\n      (throw (str \"unknown operator \" op-str))))\r\n\r\n(defn evaluate [expr]\r\n  (if-let [[_ exprs] (re-matches #\"What is (.+)\\?\" expr)]\r\n    (if-let [[token & tokens] (re-seq tokens-pattern exprs)]\r\n      (reduce (fn [acc [op x]]\r\n                ((parse-op op) acc (Integer/parseInt x)))\r\n              (Integer/parseInt token) (partition-all 2 tokens))\r\n      (throw \"no arithmetic expression found\"))\r\n    (throw \"cannot recognize question\")))\r\n",
    "sieve" : "(defn prime? [n]\r\n  (->> n\r\n       Math/sqrt\r\n       Math/floor\r\n       inc\r\n       (range 2)\r\n       (filter #(zero? (rem n %)))\r\n      empty?))\r\n(defn sieve [n]\r\n  (->> n\r\n       inc\r\n       (range 2)\r\n       (filter prime?)))\r\n",
    "binary" : "(defn power [[exponent bit]]\r\n  (if (= \"1\" bit)\r\n    (Math/pow 2 exponent)\r\n    0))\r\n\r\n(defn bits [string]\r\n  (->> string\r\n       (re-seq #\"[10]\")\r\n       reverse\r\n       (map-indexed vector)))\r\n\r\n(defn to-decimal [string]\r\n  (->> string\r\n       bits\r\n       (map power)\r\n       (apply +)))\r\n",
    "pig_latin" : "(defn starts-with-any [prefixes word]\r\n  (some (partial str/starts-with? word) prefixes))\r\n\r\n(defn starts-with-vowel-like? [word]\r\n  (starts-with-any #{\"yt\" \"xr\"} word))\r\n\r\n(defn starts-with-vowel? [word]\r\n  (starts-with-any #{\"a\" \"e\" \"i\" \"o\" \"u\"} word))\r\n\r\n(defn starts-with-two-letter-prefix? [word]\r\n  (starts-with-any #{\"ch\" \"qu\" \"th\" \"rh\"} word))\r\n\r\n(defn starts-with-three-letter-prefix? [word]\r\n  (starts-with-any #{\"thr\" \"sch\"} word))\r\n\r\n(defn starts-with-qu-and-preceding-consonant? [word]\r\n  (and (not (starts-with-vowel? word))\r\n       (str/starts-with? (subs word 1) \"qu\")))\r\n\r\n(defn rotate [word n]\r\n  (str (subs word n) (subs word 0 n)))\r\n\r\n(defn append-ay [word]\r\n  (str word \"ay\"))\r\n\r\n(defn translate-word [word]\r\n  (cond\r\n    (or (starts-with-vowel? word)\r\n        (starts-with-vowel-like? word))\r\n    (append-ay word)\r\n\r\n    (or\r\n     (starts-with-three-letter-prefix? word)\r\n     (starts-with-qu-and-preceding-consonant? word))\r\n    (append-ay (rotate word 3))\r\n\r\n    (starts-with-two-letter-prefix? word)\r\n    (append-ay (rotate word 2))\r\n\r\n    :else\r\n    (append-ay (rotate word 1))))\r\n\r\n(defn translate [words]\r\n  (->> (str/split words #\" \")\r\n       (map translate-word)\r\n       (str/join \" \")))\r\n",
    "bob" : "(defn remove-whitespace [s]\r\n  (js-eval (str \"\\\"\" s \"\\\"\" \".replace(/\\\\s+/g, '')\")))\r\n\r\n(defn silence?    [msg] (= \"\" (remove-whitespace msg)))\r\n\r\n(defn question?   [msg] (= \"?\" (last msg)))\r\n\r\n(defn has-letter? [msg] (some #(Character/isLetter %) msg))\r\n\r\n(defn shouting?   [msg] (and (= msg (str/upper-case msg))\r\n                              (has-letter? msg)))\r\n\r\n(defn forceful-question? [msg]\r\n  (and (shouting? msg) (question? msg)))\r\n\r\n(defn response-for [input]\r\n  (let [clean (str/trim input)]\r\n    (cond\r\n      (forceful-question? clean) \"Calm down, I know what I'm doing!\"\r\n      (silence?  clean) \"Fine. Be that way!\"\r\n      (shouting? clean) \"Whoa, chill out!\"\r\n      (question? clean) \"Sure.\"\r\n      :else             \"Whatever.\")))\r\n",
    "rna_transcription" : "(defn dna->rna [x]\r\n (cond \r\n (= x \"G\") \"C\"\r\n (= x \"C\") \"G\" \r\n (= x \"A\") \"U\"\r\n (= x \"T\") \"A\")) \r\n\r\n(dna->rna \"C\") \r\n\r\n (defn- translate [c]\r\n (dna->rna c)) \r\n\r\n(defn to-rna [dna]\r\n (apply str (map translate dna)))\r\n",
    "pascals_triangle" : "(defn next-row [row]\r\n  (let [padded (concat [0] row [0])\r\n        partitioned (partition 2 1 padded)]\r\n    (vec (map #(reduce + 0 %) partitioned))))\r\n\r\n(defn row-helper [n accum]\r\n  (cond (= n 1) (reverse accum)\r\n        :else (row-helper (dec n) (cons (next-row (first accum)) accum))))\r\n\r\n(defn triangle-fn [n]\r\n  (row-helper n (list [1])))\r\n\r\n(def triangle (triangle-fn 3))\r\n\r\n(defn row [n]\r\n  (last (triangle-fn n)))\r\n",
    "space_age" : "(def year-seconds (* 365.25 24 60 60))\r\n\r\n(defmacro defperiod [planet ratio]\r\n  `(defn ~(symbol (str \"on-\" planet))\r\n     [seconds#]\r\n     (/ seconds# (* ~ratio year-seconds))))\r\n\r\n(defperiod \"earth\"   1.0)\r\n(defperiod \"mercury\" 0.2408467)\r\n(defperiod \"venus\"   0.61519726)\r\n(defperiod \"mars\"    1.8808158)\r\n(defperiod \"jupiter\" 11.862615)\r\n(defperiod \"saturn\"  29.447498)\r\n(defperiod \"uranus\"  84.016846)\r\n(defperiod \"neptune\" 164.79132)\r\n",
    "queen_attack" : "(defn abs [n]\r\n  (if (neg? n) (- n) n))\r\n\r\n(defn board->str [board]\r\n  (->> board\r\n       (map #(str/join \" \" %))\r\n       (map #(str % \"\\n\"))\r\n       (apply str)))\r\n\r\n(defn cell-string [{:keys [w b]} coords]\r\n  (cond\r\n    (= coords w) \"W\"\r\n    (= coords b) \"B\"\r\n    :else \"_\"))\r\n\r\n(defn row-string [queens row]\r\n  (->> (range 8)\r\n       (map #(cell-string queens [row, %]))\r\n       (str/join \" \")))\r\n\r\n(defn board-string [queens]\r\n  (->> (range 8)\r\n       (map #(row-string queens %))\r\n       (map #(str % \"\\n\"))\r\n       str/join))\r\n\r\n(defn can-attack [{:keys [w b]}]\r\n  (let [diffs (map #(abs (- %1 %2)) w b)]\r\n    (or (some zero? diffs)\r\n        (apply = diffs))))\r\n",
    "acronym" : "(defn acronym [text]\r\n  (->> (re-seq #\"[A-Z]+[a-z]*|[a-z]+\" text)\r\n       (map ffirst)\r\n       (apply str)\r\n       str/upper-case))\r\n",
    "secret_handshake" : "(defn int->reversed-binary [int]\r\n  (-> int\r\n      (Integer/toBinaryString)\r\n      (reverse)))\r\n\r\n(defn convert [integer]\r\n  (remove nil?\r\n          (map (fn [command binary]\r\n                 (when (= \\1 binary) command))\r\n               [\"wink\" \"double blink\" \"close your eyes\" \"jump\"]\r\n               (int->reversed-binary integer))))\r\n\r\n(defn commands [integer]\r\n  (let [cmds (convert integer)]\r\n    (if (= \\1 (nth (int->reversed-binary integer) 4 \"0\"))\r\n      (reverse cmds)\r\n      cmds)))\r\n",
    "crypto_square" : "(defn normalize-plaintext [plaintext]\r\n  (str/lower-case (str/replace plaintext #\"[^\\w]\" \"\")))\r\n\r\n(defn square-size [plaintext]\r\n  (int (Math/ceil (Math/sqrt (count (normalize-plaintext plaintext))))))\r\n\r\n(defn plaintext-segments [plaintext]\r\n  (let [normalized-plaintext (normalize-plaintext plaintext)\r\n        size (square-size normalized-plaintext)]\r\n    (map #(apply str %) (partition size size normalized-plaintext))))\r\n\r\n(defn padded-segments [plaintext pad]\r\n  (let [segments (plaintext-segments plaintext)\r\n        r (count (first segments))]\r\n        (map #(concat % (take (- r (count %)) (repeat pad))) segments)))\r\n\r\n(defn ciphertext [plaintext]\r\n  (apply str (apply mapcat vector (padded-segments plaintext nil))))\r\n\r\n(defn normalize-ciphertext [plaintext]\r\n  (str/join \" \" (map #(apply str %) (apply map vector (padded-segments plaintext \\ )))))\r\n",
    "word_count" : "(defn words [s]\r\n  (re-seq #\"\\\\w+\" s))\r\n\r\n(defn word-count [s]\r\n  (-> s lower-case words frequencies))\r\n",
    "armstrong_numbers" : "(defn expt [base pow]\r\n  (reduce * 1 (repeat pow base)))\r\n\r\n(defn armstrong? [n]\r\n  (let [digits (map #(read-string (str %)) (str n))\r\n        l      (count digits)]\r\n  (= n (reduce + 0 (map #(expt % l) digits)))))\r\n",
    "hamming" : "(defn distance [a b]\r\n  (if (or (empty? a) (empty? b)) 0\r\n    (when (= (count a) (count b))\r\n      (count (filter true? (map not= a b))))))\r\n",
    "scrabble_score" : "(def  letter-values\r\n  {\"AEIOULNRST\" 1\r\n   \"DG\"         2\r\n   \"BCMP\"       3\r\n   \"FHVWY\"      4\r\n   \"K\"          5\r\n   \"JX\"         8\r\n   \"QZ\"        10})\r\n\r\n;; A map from letter (as string) to score\r\n(def  letter->score\r\n  (reduce-kv (fn [acc letters score]\r\n               (-> (map str letters)\r\n                   (zipmap (repeat (count letters) score))\r\n                   (->> (merge acc))))\r\n             {} letter-values))\r\n\r\n;; Defaults to 0 for non-alphabetic input\r\n(defn score-letter [letter]\r\n  (get letter->score (.toUpperCase (str letter)) 0))\r\n\r\n(defn score-word [word]\r\n  (reduce (fn [score letter]\r\n            (+ score (score-letter letter)))\r\n          0 word))\r\n",
    "octal" : "(def DIGIT-VALUES {\"0\" 0 \"1\" 1  \"2\" 2 \"3\" 3 \"4\" 4 \"5\" 5 \"6\" 6 \"7\" 7})\r\n\r\n(defn digit-to-value [dgt-char]\r\n (- (int dgt-char) (int \"0\")))\r\n\r\n(defn to-decimal [oct-str]\r\n  (if (every? #(get DIGIT-VALUES %) oct-str)\r\n(reduce (fn [value digit]\r\n           (+ (* 8 value) (digit-to-value digit)))\r\n    0 (seq oct-str))\r\n   0)))\r\n",
    "raindrops" : "(defn convert [n]\r\n  (cond\r\n    (and (= 0 (mod n 3)) (= 0 (mod n 5)) (= 0 (mod n 7))) \"PlingPlangPlong\"\r\n    (and (= 0 (mod n 3)) (= 0 (mod n 5))) \"PlingPlang\"\r\n    (and (= 0 (mod n 3)) (= 0 (mod n 7))) \"PlingPlong\"\r\n    (and (= 0 (mod n 5)) (= 0 (mod n 7))) \"PlangPlong\"\r\n    (= 0 (mod n 3)) \"Pling\"\r\n    (= 0 (mod n 5)) \"Plang\"\r\n    (= 0 (mod n 7)) \"Plong\"\r\n    :else (str n)))\r\n",
    "binary_search_tree" : "(defn singleton [v] {:v v :r nil :l nil})\r\n(def value :v)\r\n(def left :l)\r\n(def right :r)\r\n\r\n(defn insert [v t]\r\n  (cond (nil? t) {:v v}\r\n        (<= v (:v t)) (assoc t :l (insert v (:l t)))\r\n        :else (assoc t :r (insert v (:r t)))))\r\n\r\n(defn from-list [vs]\r\n  (reduce (fn [a b] (insert b a)) nil vs))\r\n\r\n(defn to-list [t]\r\n  (if t\r\n    (concat (to-list (:l t)) [(:v t)] (to-list (:r t)))\r\n    []))\r\n",
    "nth_prime" : "(defn sqrt\r\n  \"Wrapper around java's sqrt method.\"\r\n  [number]\r\n  (int (Math/ceil (Math/sqrt number))))\r\n\r\n(defn divides?\r\n  \"Helper function to decide if a number is evenly divided by divisor.\"\r\n  [number divisor]\r\n  (zero? (mod number divisor)))\r\n\r\n(defn prime? [n]\r\n  (not-any? zero? (map #(rem n %) (range 2 n))))\r\n\r\n(defn next-prime [start]\r\n  (loop [n (inc start)]\r\n    (if (prime? n)\r\n      n\r\n      (recur (inc n)))))\r\n\r\n(def primes (iterate next-prime 1))\r\n\r\n(defn nth-prime [index]\r\n  (when-not (pos? index)\r\n    (throw \"nth-prime expects a positive integer for an argument\"))\r\n  (nth primes index))\r\n",
    "largest_series_product" : "(defn char->digit [c]\r\n  (Character/digit c 10))\r\n\r\n(defn digits [ds] (map char->digit ds))\r\n\r\n(defn slices [n ds] (partition n 1 (digits ds)))\r\n\r\n(defn largest-product [size ds]\r\n  (cond\r\n    (zero? size)        1\r\n    (> size (count ds)) (throw \"Span must not exceed length.\")\r\n    :else               (apply max (map (partial apply *) (slices size ds)))))\r\n",
    "protein_translation" : "(defn translate-codon [codon]\r\n  (cond\r\n    (= codon \"AUG\") \"Methionine\"\r\n    (= codon \"UUU\") \"Phenylalanine\"\r\n    (= codon \"UUC\") \"Phenylalanine\"\r\n    (= codon \"UUA\") \"Leucine\"\r\n    (= codon \"UUG\") \"Leucine\"\r\n    (= codon \"UCU\") \"Serine\"\r\n    (= codon \"UCC\") \"Serine\"\r\n    (= codon \"UCA\") \"Serine\"\r\n    (= codon \"UCG\") \"Serine\"\r\n    (= codon \"UAU\") \"Tyrosine\"\r\n    (= codon \"UAC\") \"Tyrosine\"\r\n    (= codon \"UGU\") \"Cysteine\"\r\n    (= codon \"UGC\") \"Cysteine\"\r\n    (= codon \"UGG\") \"Tryptophan\"\r\n    (= codon \"UAA\") \"STOP\"\r\n    (= codon \"UAG\") \"STOP\"\r\n    (= codon \"UGA\") \"STOP\"))\r\n\r\n(defn translate-rna [rna]\r\n  (->> rna\r\n       (partition 3)\r\n       (map (partial apply str))\r\n       (map translate-codon)\r\n       (take-while #(not= \"STOP\" %))))\r\n",
    "sublist" : "(defn list-contains?\r\n  \"Returns truthy when list2 is contained within list1, nil otherwise\"\r\n  [list1 list2]\r\n  (some #(when (= % list2) val)\r\n        (partition (count list2) 1 list1)))\r\n\r\n(defn classify\r\n  \"Classifies two lists based on whether coll1 is the same list, a superlist,\r\n  a sublist, or disjoint (unequal) from coll2.\"\r\n  [coll1 coll2]\r\n  (let [len1 (count coll1)\r\n        len2 (count coll2)]\r\n    (cond\r\n      (= coll1 coll2) :equal\r\n      (and (> len1 len2) (list-contains? coll1 coll2)) :superlist\r\n      (and (> len2 len1) (list-contains? coll2 coll1)) :sublist\r\n      :else :unequal)))\r\n",
    "prime_factors" : "(defn least-prime-divisor\r\n  [number]\r\n  (or (first\r\n       (filter #(zero? (rem number %1))\r\n               (range 2 (inc (/ number 2)))))\r\n      number))\r\n\r\n(defn of [number]\r\n  (if\r\n   (< number 2) []\r\n   (let [divisor (least-prime-divisor number)]\r\n     (into [divisor] (of (/ number divisor))))))\r\n",
    "triangle" : "(defn is-valid? [s1 s2 s3]\r\n  (and\r\n   (> s1 0) (> s2 0) (> s3 0)\r\n   (>= (+ s1 s2) s3)\r\n   (>= (+ s1 s3) s2)\r\n   (>= (+ s2 s3) s1)))\r\n\r\n(defn equilateral? [s1 s2 s3]\r\n  (and (is-valid? s1 s2 s3) (= s1 s2 s3)))\r\n\r\n(defn isosceles? [s1 s2 s3]\r\n  (and (is-valid? s1 s2 s3) (or (= s1 s2) (= s1 s3) (= s2 s3))))\r\n\r\n(defn scalene? [s1 s2 s3]\r\n  (and (not (isosceles? s1 s2 s3)) (is-valid? s1 s2 s3)))\r\n",
    "reverse_string" : "(ns reverse-string)\r\n\r\n(defn reverse-string [s] (apply str (reverse s)))\r\n",
    "beer_song" : "(defn verse [n]\r\n  (cond\r\n        (= n 0) (str \"No more bottles of beer on the wall, no more bottles of beer.\\n\"\r\n                     \"Go to the store and buy some more, 99 bottles of beer on the wall.\\n\")\r\n        (= n 1) (str \"1 bottle of beer on the wall, 1 bottle of beer.\\n\"\r\n                     \"Take it down and pass it around, no more bottles of beer on the wall.\\n\")\r\n        (= n 2) (str \"2 bottles of beer on the wall, 2 bottles of beer.\\n\"\r\n                     \"Take one down and pass it around, 1 bottle of beer on the wall.\\n\")\r\n        :else (str n \" bottles of beer on the wall, \" n \" bottles of beer.\\n\"\r\n                   \"Take one down and pass it around, \" (dec n) \" bottles of beer on the wall.\\n\")))\r\n\r\n(defn sing\r\n  ([start]\r\n   (sing start 0))\r\n  ([start end]\r\n  (->> (reverse (range end (inc start)))\r\n          (map verse)\r\n          (str/join \"\n\"))))\r\n",
    "binary_search" : "(defn middle [alist]\r\n  (-> alist (count) (quot 2)))\r\n\r\n(defn search-for\r\n  [elem alist]\r\n  (let [middle (middle alist)\r\n        cur-elem (nth alist middle)]\r\n    (cond\r\n      (= cur-elem elem) middle\r\n      (or (= middle (count alist)) (zero? middle)) (throw \"not found in list\")\r\n      (< cur-elem elem) (+ middle (search-for elem (drop middle alist)))\r\n      (> cur-elem elem) (search-for elem (take middle alist)))))\r\n",
    "clock" : "(defn clock [in-hour in-minute]\r\n  (let [total-minutes (mod (+ (* in-hour 60) in-minute) (* 60 24))\r\n        hours (mod (quot total-minutes 60) 24)\r\n        minutes (mod total-minutes 60)]\r\n    {:hour hours :minute minutes}))\r\n\r\n(defn fmt2 [n]\r\n  (if (= (count (str n)) 1) (str 0 n) n))\r\n\r\n(defn clock->string [in-clock]\r\n  (str (fmt2 (:hour in-clock)) \":\" (fmt2 (:minute in-clock))))\r\n\r\n(defn add-time [in-clock minutes-to-add]\r\n  (clock (:hour in-clock) (+ (:minute in-clock) minutes-to-add)))\r\n",
    "allergies" : "(defn allergies [s]\r\n  (cond-> []\r\n    (bit-test s 0) (conj :eggs)\r\n    (bit-test s 1) (conj :peanuts)\r\n    (bit-test s 2) (conj :shellfish)\r\n    (bit-test s 3) (conj :strawberries)\r\n    (bit-test s 4) (conj :tomatoes)\r\n    (bit-test s 5) (conj :chocolate)\r\n    (bit-test s 6) (conj :pollen)\r\n    (bit-test s 7) (conj :cats)))\r\n\r\n(defn allergic-to? [score substance]\r\n  (some #{substance} (allergies score)))\r\n",
    "say" : "(def english-cardinal-units\r\n  [\"zero\" \"one\" \"two\" \"three\" \"four\" \"five\" \"six\" \"seven\" \"eight\" \"nine\"\r\n   \"ten\" \"eleven\" \"twelve\" \"thirteen\" \"fourteen\"\r\n   \"fifteen\" \"sixteen\" \"seventeen\" \"eighteen\" \"nineteen\"])\r\n(def english-cardinal-tens\r\n  [\"\" \"\" \"twenty\" \"thirty\" \"forty\" \"fifty\" \"sixty\" \"seventy\" \"eighty\" \"ninety\"])\r\n\r\n(def english-scale-numbers\r\n  [\"\" \"thousand\" \"million\" \"billion\" \"trillion\" \"quadrillion\" \"quintillion\"\r\n   \"sextillion\" \"septillion\" \"octillion\" \"nonillion\" \"decillion\"\r\n   \"undecillion\" \"duodecillion\" \"tredecillion\" \"quattuordecillion\"\r\n   \"quindecillion\" \"sexdecillion\" \"septendecillion\"\r\n   \"octodecillion\" \"novemdecillion\" \"vigintillion\"])\r\n\r\n(defn add-english-scales\r\n  [parts offset]\r\n  (let [cnt (count parts)]\r\n    (loop [acc []\r\n           pos (dec cnt)\r\n           this (first parts)\r\n           remainder (next parts)]\r\n      (if (nil? remainder)\r\n        (str (apply str (interpose \" \" acc))\r\n             (if (and (not (empty? this)) (not (empty? acc))) \" \")\r\n             this\r\n             (if (and (not (empty? this)) (pos? (+ pos offset)))\r\n               (str \" \" (nth english-scale-numbers (+ pos offset)))))\r\n        (recur\r\n  (if (empty? this)\r\n           acc\r\n           (conj acc (str this \" \" (nth english-scale-numbers (+ pos offset)))))\r\n         (dec pos)\r\n         (first remainder)\r\n         (next remainder))))))\r\n\r\n(defn format-simple-cardinal [num]\r\n  (let [hundreds (quot num 100)\r\n        tens (rem num 100)]\r\n    (str\r\n     (if (pos? hundreds) (str (nth english-cardinal-units hundreds) \" hundred\"))\r\n     (if (and (pos? hundreds) (pos? tens)) \" \")\r\n     (if (pos? tens)\r\n       (if (< tens 20)\r\n         (nth english-cardinal-units tens)\r\n         (let [ten-digit (quot tens 10)\r\n               unit-digit (rem tens 10)]\r\n           (str\r\n            (if (pos? ten-digit) (nth english-cardinal-tens ten-digit))\r\n            (if (and (pos? ten-digit) (pos? unit-digit)) \"-\")\r\n            (if (pos? unit-digit) (nth english-cardinal-units unit-digit)))))))))\r\n\r\n(defn consume [func initial-context]\r\n       (loop [context initial-context\r\n              acc []]\r\n         (let [[result new-context] (apply func [context])]\r\n           (if (not result)\r\n             [acc new-context]\r\n             (recur new-context (conj acc result))))))\r\n\r\n(defn remainders [base val]\r\n  (reverse\r\n   (first\r\n    (consume #(if (pos? %)\r\n                [(rem % base) (quot % base)]\r\n                [nil nil])\r\n             val))))\r\n\r\n(defn number [n]\r\n  (if (= 0 n)\r\n    \"zero\"\r\n    (let [abs-arg (if (neg? n) (- n) n)\r\n          parts (remainders 1000 abs-arg)]\r\n      (let [parts-strs (map format-simple-cardinal parts)\r\n            full-str (add-english-scales parts-strs 0)]\r\n        (str (if (neg? n) \"minus \") full-str)))))\r\n",
    "luhn" : "(defn double [n]\r\n  (if (> n 4)\r\n    (+ n n -9)\r\n    (+ n n)))\r\n\r\n(defn sum [input]\r\n  (->> input\r\n       (re-seq #\"\\\\d\")\r\n       (map #(Integer/parseInt %))\r\n       reverse\r\n      (partition 2 2 [0])\r\n       (reduce (fn [sum a-b] (+ sum (first a-b) (double (last a-b)))) 0)))\r\n\r\n(defn valid? [input]\r\n  (boolean\r\n    (and (re-matches #\"[\\\\d\\\\s]*\" input)\r\n         (zero? (rem (sum input) 10))\r\n         (< 1 (count (re-seq #\"\\\\d\" input))))))\r\n",
    "difference_of_squares" : "(defn sum [xs] (reduce + 0 xs))\r\n\r\n(defn sum-of-squares [n]\r\n    (sum (map #(int (Math/pow % 2)) (range 0 (inc n)))))\r\n\r\n(defn square-of-sum [n]\r\n    (int (Math/pow (sum (range 0 (inc n))) 2)))\r\n\r\n(defn difference [x]\r\n    (- (square-of-sum x) (sum-of-squares x)))\r\n",
    "complex_numbers" : "(defn real [c] (first c))\r\n\r\n(defn imaginary [c] (last c))\r\n\r\n(defn abs [c] (Math/sqrt (apply + (map #(Math/pow % 2) [(first c) (last c)]))))\r\n\r\n(defn conjugate [c] [(first c) (- (last c))])\r\n\r\n(defn add [c1 c2] [(+ (first c1) (first c2)) (+ (last c1) (last c2))])\r\n\r\n(defn sub [c1 c2] [(- (first c1) (first c2)) (- (last c1) (last c2))])\r\n\r\n(defn mul [c1 c2] [(- (* (first c1) (first c2)) (* (last c1) (last c2)))\r\n             (+ (* (first c1) (last c2)) (* (last c1) (first c2)))])\r\n\r\n(defn div [c1 c2]\r\n  (when-not (== 0 c1 c2)\r\n    (let [x (+ (* (first c2) (first c2)) (* (last c2) (last c2)))]\r\n      [(double (/ (+ (* (first c1) (first c2)) (* (last c1) (last c2))) x))\r\n       (double (/ (- (* (last c1) (first c2)) (* (first c1) (last c2))) x))])))\r\n",
    "poker" : "(def base-values\r\n  {\"2\" 2\r\n   \"3\" 3\r\n   \"4\" 4\r\n   \"5\" 5\r\n   \"6\" 6\r\n   \"7\" 7\r\n   \"8\" 8\r\n   \"9\" 9\r\n   \"10\" 10\r\n   \"J\" 11\r\n   \"Q\" 12\r\n   \"K\" 13})\r\n\r\n(def values-low-as\r\n  (into base-values\r\n        {\"A\" 1}))\r\n\r\n(def values-high-as\r\n  (into base-values\r\n        {\"A\" 14}))\r\n\r\n#_(defn value-freq [hand]\r\n  (->> hand\r\n       (group-by :value)\r\n       (vals)\r\n       (map count)\r\n       (sort)))\r\n\r\n#_(defn one-pair? [hand]\r\n  (= [1 1 1 2] (value-freq hand)))\r\n\r\n#_(defn two-pair? [hand]\r\n  (= [1 2 2] (value-freq hand)))\r\n\r\n#_(defn three-of-a-kind? [hand]\r\n  (= [1 1 3] (value-freq hand)))\r\n\r\n#_(defn straight? [hand]\r\n  (->> hand\r\n       (map :value)\r\n       (sort)\r\n       (partition 2 1)\r\n       (map (partial apply -))\r\n       (every? (partial = -1))))\r\n\r\n#_(defn flush? [hand]\r\n  (->> hand\r\n       (map :color)\r\n       (apply =)))\r\n\r\n#_(defn full-house? [hand]\r\n  (= [2 3] (value-freq hand)))\r\n\r\n#_(defn four-of-a-kind? [hand]\r\n  (= [1 4] (value-freq hand)))\r\n\r\n#_(defn straight-flush? [hand]\r\n  (and (flush? hand) (straight? hand)))\r\n\r\n#_(defn category [hand]\r\n  (condp #(%1 %2) hand\r\n    straight-flush? 8\r\n    four-of-a-kind? 7\r\n    full-house? 6\r\n    flush? 5\r\n    straight? 4\r\n    three-of-a-kind? 3\r\n    two-pair? 2\r\n    one-pair? 1\r\n    0))\r\n\r\n#_(defn highcards [hand]\r\n  (->> hand\r\n       (map :value)\r\n       (frequencies)\r\n       (map reverse)\r\n       (map vec)\r\n       (sort)\r\n       (reverse)\r\n       (vec)))\r\n\r\n#_(defn read-hand [raw-hand values]\r\n  (vec (for [[_ rank color] (re-seq #\"(\\d+|[JQKA])([CDHS])\" raw-hand)]\r\n         {:value (values rank)\r\n          :color color})))\r\n\r\n#_(defn score\r\n  ([raw-hand]\r\n   (last (sorted-set (score raw-hand values-high-as)\r\n                     (score raw-hand values-low-as))))\r\n  ([raw-hand values]\r\n   (-> raw-hand\r\n       (read-hand values)\r\n       ((juxt category highcards)))))\r\n\r\n#_(defn max-by-score [raw-hands]\r\n  (->> raw-hands\r\n       (group-by score)\r\n       (into (sorted-map))\r\n       (vals)\r\n       (last)))\r\n\r\n#_(defn best-hands [hands]\r\n  (max-by-score hands))\r\n",
    "go_counting" : "(defn get-point [grid [x y]]\r\n  (get-in grid [y x]))\r\n\r\n(defn adj [grid [x y]]\r\n  (->> [[(inc x) y] [(dec x) y] [x (inc y)] [x (dec y)]]\r\n       (filter #(get-point grid %))))\r\n\r\n(defn update-owner [old new]\r\n  (when (#{new :unknown} old) new))\r\n\r\n(defn territory [grid point]\r\n  (loop [[p & more] [point]\r\n         {:keys [stones] :as res} {:stones #{} :owner :unknown}]\r\n    (cond\r\n      (nil? p) (update res :owner #(when (seq stones) (#{:white :black} %)))\r\n      (stones p) (recur more res)\r\n      :else (if-let [owner (-> (get-point grid p) {\\W :white \\B :black})]\r\n              (recur more (update res :owner update-owner owner))\r\n              (recur (concat more (adj grid p)) (update res :stones conj p))))))\r\n\r\n(defn all-points [grid]\r\n  (for [x (range (count (first grid)))\r\n        y (range (count grid))]\r\n    [x y]))\r\n\r\n(def owner-key-mapping\r\n  {:black :black-territory :white :white-territory nil :null-territory})\r\n\r\n(defn territories [grid]\r\n  (loop [[p & more] (all-points grid)\r\n         res {:black-territory #{} :white-territory #{} :null-territory #{}}]\r\n    (cond\r\n      (nil? p) res\r\n      (some #(% p) (vals res)) (recur more res)\r\n      :else (let [{:keys [stones owner]} (territory grid p)\r\n                  k (owner-key-mapping owner)]\r\n              (recur more (update res k into stones))))))\r\n",
    "accumulate" : "(defn accumulate [f xs]\r\n   (loop [xs xs\r\n         accum []]\r\n      (if (empty? xs)\r\n          accum\r\n         (recur (rest xs) (conj accum (f (first xs)))))))\r\n",
    "hexadecimal" : "(defn- char-between [start end c]  (let [ascii (int c)]\r\n    (and (>= ascii (int start)) (<= ascii (int end)))))\r\n\r\n(def is-digit (partial char-between \\0 \\9))\r\n(def is-a-to-f (partial char-between \\a \\f))\r\n\r\n(defn- is-hex-digit [c]\r\n  (or (is-digit c) (is-a-to-f c)))\r\n\r\n(defn- digit-to-int [c]\r\n  (cond\r\n    (is-digit c) (- (int c) (int \\0))\r\n    (is-a-to-f c) (+ (- (int c) (int \\a)) 10)\r\n    :else (throw \"Character is not a hex digit\")))\r\n\r\n(defn hex-to-int [digits]\r\n  (if\r\n   (some (complement is-hex-digit) digits) 0\r\n   (reduce (fn [a b] (+ (digit-to-int b) (* a 16))) 0 digits)))\r\n",
    "series" : "(defn slices [string n]\r\n  (if (zero? n)\r\n    [\"\"]\r\n    (loop [string string, acc []]\r\n      (if (< (count string) n)\r\n        acc\r\n        (recur (rest string) (conj acc (apply str (take n string))))))))\r\n",
    "yacht" : "(defn yacht [dices]\r\n  (if (= (count (set dices)) 1) 50 0))\r\n\r\n(defn dice-frequencies [dices]\r\n  (mapv #(if (nil? %) 0 %)\r\n        (map (fn [v] (get (frequencies dices) v))\r\n             (range 1 7))))\r\n\r\n(defn appearances [dices diceValue]\r\n  (get (dice-frequencies dices) (dec diceValue)))\r\n\r\n(defn getSumOfDices [dices]\r\n  (reduce + 0 dices))\r\n\r\n(defn four-of-kind [dices]\r\n  (let [counterArray (dice-frequencies dices)\r\n        scores (remove nil? (for [i (range 6)]\r\n                              (when (>= (get counterArray i) 4)\r\n                                (* 4 (inc i)))))]\r\n    (if (empty? scores) 0 (first scores))))\r\n\r\n(defn little-straight [dices]\r\n  (if (= (sort dices) [1 2 3 4 5]) 30 0))\r\n\r\n(defn big-straight [dices]\r\n  (if (= (sort dices) [2 3 4 5 6]) 30 0))\r\n\r\n(defn full-house [dices]\r\n  (let [counterArray (dice-frequencies dices)]\r\n    (if (and (contains? (set counterArray) 2)\r\n             (contains? (set counterArray) 3))\r\n      (reduce + 0 dices)\r\n      0)))\r\n\r\n(defn score [dices category]\r\n  (cond\r\n    (= category \"yacht\") (yacht dices)\r\n    (= category \"ones\") (appearances dices 1)\r\n    (= category \"twos\") (* 2 (appearances dices 2))\r\n    (= category \"threes\") (* 3 (appearances dices 3))\r\n    (= category \"fours\") (* 4 (appearances dices 4))\r\n    (= category \"fives\") (* 5 (appearances dices 5))\r\n    (= category \"sixes\") (* 6 (appearances dices 6))\r\n    (= category \"full house\") (full-house dices)\r\n    (= category \"four of a kind\") (four-of-kind dices)\r\n    (= category \"little straight\") (little-straight dices)\r\n    (= category \"big straight\") (big-straight dices)\r\n    (= category \"choice\") (getSumOfDices dices)\r\n    :else 0))\r\n",
    "grains" : "(defn square [number]\r\n  (Math/pow 2 (dec number)))\r\n\r\n(def  square-numbers (rest (range 65)))\r\n\r\n(defn total []\r\n  (apply + (map square square-numbers)))\r\n",
    "robot_simulator" : "(defn robot [coordinates bearing]\r\n  {:coordinates coordinates :bearing bearing})\r\n\r\n(def turn-right\r\n  {:north :east, :east :south,\r\n   :south :west, :west :north})\r\n\r\n(def turn-left\r\n  (zipmap (vals turn-right) (keys turn-right)))\r\n\r\n(def advance\r\n  {:north #(update % :y inc)\r\n   :east  #(update % :x inc)\r\n   :south #(update % :y dec)\r\n   :west  #(update % :x dec)})\r\n\r\n(defn command [robot command]\r\n  (cond\r\n    (= command \"A\") (update robot :coordinates (advance (:bearing robot)))\r\n    (= command \"R\") (update robot :bearing turn-right)\r\n    (= command \"L\") (update robot :bearing turn-left)))\r\n\r\n(defn simulate [commands robot]\r\n  (reduce command robot commands))\r\n",
    "proverb" : "(defn all-for-the-want [thing]\r\n  (str \"And all for the want of a \" thing \".\"))\r\n\r\n(defn for-the-want [things]\r\n  (if (= 1 (count things))\r\n    \"\"\r\n    (str \"For want of a \" (first things) \" the \" (second things) \" was lost.\\n\" (for-the-want (rest things)))))\r\n\r\n(defn recite [things]\r\n  (if (empty? things)\r\n    \"\"\r\n    (str (for-the-want things) (all-for-the-want (first things)))))\r\n",
    "flatten_array" : "(defn flatten [s]\r\n  (->> s\r\n       (tree-seq sequential? seq)\r\n       rest\r\n       (remove sequential?)\r\n       (remove nil?)))\r\n",
    "pangram" : "(defn pangram? [string]\r\n  (= 26 (count (frequencies (re-seq #\"[a-z]\" (str/lower-case string))))))\r\n",
    "bank_account" : "(defn open-account []\r\n  (atom 0))\r\n\r\n(defn close-account [acct]\r\n  (reset! acct nil))\r\n\r\n(defn get-balance [acct]\r\n  @acct)\r\n\r\n(defn update-balance [account amount]\r\n  (swap! account + amount))\r\n",
    "strain" : "(defn retain [pred coll]\r\n  (reduce\r\n    (fn [acc x] (if (pred x) (conj acc x) acc))\r\n     []\r\n   coll))\r\n\r\n(defn discard [pred coll]\r\n  (retain (complement pred) coll))\r\n",
    "sum_of_multiples" : "(defn sum-of-multiples [multiples upperbound]\r\n  (if (empty? multiples) 0\r\n    (->> multiples\r\n         (mapcat #(range 0 upperbound %))\r\n         set\r\n         (reduce + 0))))\r\n",
    "collatz_conjecture" : "(defn collatz [num]\r\n  (loop [num   num\r\n         total 0]\r\n    (cond\r\n      (< num 1)   (throw \"Can't deal with negativity\")\r\n      (= num 1)   total\r\n      (even? num) (recur (/ num 2)       (inc total))\r\n      :else       (recur (+ (* 3 num) 1) (inc total)))))\r\n",
    "trinary" : "(def base 3)\r\n\r\n(defn to-int [digit]\r\n    (- (int digit) (int \"0\")))\r\n\r\n(defn valid-digit? [digit]\r\n    (let [n (to-int digit)]\r\n      (and (>= n 0) (< n base))))\r\n\r\n(defn valid-number? [str]\r\n    (empty? (remove valid-digit? str)))\r\n\r\n(defn scale-then-add-digit [accumulator digit]\r\n    (+ (* accumulator base) (to-int digit)))\r\n\r\n(defn to-decimal [str]\r\n    (if (valid-number? str) (reduce scale-then-add-digit 0 str) 0))\r\n",
    "etl" : "(defn transform [extract]\r\n  (into {}\r\n        (for [score-letters extract\r\n              letter          (last score-letters)]\r\n          [(lower-case letter) (first score-letters)])))\r\n",
    "perfect_numbers" : "(defn sum-factors [number]\r\n  (apply + (filter #(= (mod number %) 0) (range 1 number))))\r\n\r\n(defn classify [number]\r\n  (when (< number 0)\r\n    (throw \"negative number\"))\r\n  (let [sum (sum-factors number)]\r\n    (cond\r\n      (= number sum) :perfect\r\n      (> number sum) :deficient\r\n      (< number sum) :abundant)))\r\n",
    "hello_world" : "(ns hello-world)\r\n\r\n(defn hello []\r\n  \"Hello, World!\")\r\n",
    "nucleotide_count" : "(defn count-of-nucleotide-in-strand [nucleotide strand]\r\n  (count (filter #(= nucleotide %) (seq strand))))\r\n\r\n(defn nucleotide-counts [strand]\r\n  {\\A (count-of-nucleotide-in-strand \\A strand)\r\n   \\T (count-of-nucleotide-in-strand \\T strand)\r\n   \\C (count-of-nucleotide-in-strand \\C strand)\r\n   \\G (count-of-nucleotide-in-strand \\G strand)})\r\n",
    "phone_number" : "(defn digits-only\r\n  [input]  (str/replace input #\"\\\\D\" \"\"))\r\n\r\n(defn extract-parts  [input]\r\n  (if-let [matches (re-find #\"^1?([2-9]..)([2-9]..)(....)$\" input)]\r\n    (rest matches)\r\n    [\"000\" \"000\" \"0000\"]))\r\n\r\n(defn parts  [input]\r\n  (-> input\r\n      digits-only\r\n      extract-parts))\r\n\r\n(defn number [input]\r\n  (str/join (parts input)))\r\n\r\n(defn area-code [input]\r\n  (first (parts input)))\r\n\r\n(defn pretty-print [input]\r\n  (let [[area-code exchange subscriber] (parts input)]\r\n    (str \"(\" area-code \") \" exchange \"-\" subscriber)))\r\n",
    "change" : "(def algo\r\n  (memoize (fn [amount coins]\r\n             (let [smaller (filter #(<= % amount) coins)]\r\n               (if (empty? smaller) [amount]\r\n                 (apply min-key\r\n                        count\r\n                        ; check if valid solution, i.e. the final amount was zero\r\n                        (filter (comp zero? first)\r\n                                (map\r\n                                  (fn [coin]\r\n                                    (concat\r\n                                      (algo (rem amount coin) smaller)\r\n                                      (repeat (quot amount coin) coin)))\r\n                                  smaller))))))))\r\n\r\n(defn issue [amount coins] \r\n  (try\r\n    (let [[x & xs] (algo amount coins)]\r\n      (if (zero? x) xs\r\n        (throw \"cannot change\")))\r\n    ; thrown by apply min-key if we don't have the right coins to issue change\r\n    (catch \"cannot change\")))))\r\n",
    "isbn_verifier" : "(defn is-in? [xs x] (some #(= x %) xs))\r\n\r\n(defn isbn-chars [isbn]\r\n  (filter #(is-in? [\\0 \\1 \\2 \\3 \\4 \\5 \\6 \\7 \\8 \\9 \\X] %) isbn))\r\n\r\n(defn isbn? [isbn]\r\n  (let [chars (isbn-chars isbn)\r\n        nums  (map #(if (= \\X %) 10 (Character/digit % 10)) chars)]\r\n    (and (-> chars butlast (is-in? \\X) not)\r\n         (= 10 (count chars))\r\n         (as-> nums x\r\n           (map #(* %1 %2) (range 10 0 -1) x)\r\n           (reduce + 0 x)\r\n           (mod x 11)\r\n           (zero? x)))))\r\n",
    "robot_name" : "(def letters (map char (range 65 91)))\r\n\r\n(defn generate-name [] \r\n (apply str (concat (repeatedly 2 (fn [] (rand-nth letters)))  \r\n    (repeatedly 3 (fn [] (rand-int 10))))))\r\n\r\n(defn robot []\r\n  (atom (generate-name)))\r\n\r\n(defn robot-name [robot]\r\n    @robot)\r\n\r\n(defn reset-name [robot]\r\n    (reset! robot (generate-name)))\r\n"
  }