  


(debug-eval
 (get-paths-sequential '[a b c] [])
 (get-paths-associative '{x :x y :y} [])
 (get-paths 'x [3 :x])
 (get-paths '[a {b :x}] [])
 (get-paths '[a {[b c] :x}] [])
 (get-paths '{[a {[b c] :x}] :z e :e} [])
 (get-paths '[a b & c] [])
 (get-paths '{x :x y :y :or {:y 33}} [])
 (get-paths '{:keys [x y z]} [])
 (get-paths '[a {x :x [y z] :yz :or {:yz [9 8]}}] [])
 )

(debug-eval
 (let [x 3 y 4] (+ x y))
 (let [[x y] [3 4]] (+ x y))
 (let [{x :x [y z] :yz} {:x 3 :yz [4 5]}] (+ x y))
 (let [{x :x [y z] :yz :or {:yz [88 89]}} {:x 3}] (+ x y))
 (let [{x :x [y z] :yz :or {:yz [88 89] :x 4}} {}] (+ x y))
 (let [{:keys [x y]} {:x 7 :y 2}] (+ x y))
 (let [{:keys [x y] :or {:x 7 :y 2}} {}] (+ x y))
 (let [[a & v] [1 2 3]] (- (apply + v) a))
 )

(debug-eval
 ((fn ([x y] (+ x y)) ([[x y]] (recur x y))) [3 4])
 ((fn ([& v] (apply + v)) ([[x y]] (recur x y))) [3 4])
 ((fn ([& v] (apply + v)) ([[x y]] (recur x y))) [3 4 5])

 )

(comment debug-eval
 (destruct '[] [])
 (destruct '[a b c] [1 2 3])
 (destruct '[a b c & cs] (range 10))
 (destruct '{a :a b :b c :c} {:a 1 :b 2 :c 3})
 (destruct '{a :a b :b [x y & zs] :c} {:a 1 :b 2 :c (range 10)})
 (destruct '{a :a b :b [x y & zs] :c d :d :or {:d 1000}}
           {:a 1 :b 2 :c (range 10)})
 (destruct '{a :a b :b [x y & zs] :c d :d {:keys [g h]} :e :or {:d 1000}}
           {:a 1 :b 2 :c (range 10) :e {:g 100 :h 200}}))

(comment debug-eval
 (let [[] []] "nada")
 (let [[a b c] [1 2 3]] [a b c])
 (let [[a b c & cs] (range 10)] [a b c cs])
 (let [{a :a b :b c :c} {:a 1 :b 2 :c 3}] [a b c])
 (let [{a :a b :b [x y & zs] :c} {:a 1 :b 2 :c (range 10)}] [a b x y zs])
 (let [{a :a b :b [x y & zs] :c d :d :or {:d 1000}}
       {:a 1 :b 2 :c (range 10)}] [a b x y zs d])
 (let [{a :a b :b [x y & zs] :c d :d {:keys [g h]} :e :or {:d 1000}}
       {:a 1 :b 2 :c (range 10) :e {:g 100 :h 200}}] [a b x y zs d g h]))


(comment debug-eval
 (def list-of-things (range 10 20))

;; OK...
 (let [[a b c & cs] list-of-things] [a b c cs])

;; uhhh...
 (let [list-of-things (range 10)] (let [[a b c & cs] list-of-things] [a b c cs]))

;; oh, $@!#
 (defn uh-oh [list-of-things]
   (let [[a b c & cs] list-of-things]
     [a b c cs]))
 (uh-oh (range 10))

;; the beatings will continue until morale improves
 (let [list-of-things (range 10)]
   list-of-things))

; Multi Arity Functions
(comment defmacro fn+ [params & xs]
  (if (every? list? (cons params xs))
    (let* [make-pair (fn* [params-and-body]
                          (let* [params (first params-and-body)
                                 body (rest params-and-body)
                                 variadic? (some (fn* [par] (= (str par) "&")) params)
                                 k (if variadic? -1 (count params))]
                                [k [params `(do ~@body)]]))
           maf-dict (apply hash-map (apply concat (map make-pair (cons params xs))))]
          `(fn** ~maf-dict))
    `(fn-- ~params  ~@xs)))





